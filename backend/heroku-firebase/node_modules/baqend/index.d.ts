import { Observable, Subscription } from 'rxjs';

/**
 * The global JSON type.
 */
export type json = object | any[];

/**
 * A generic class type.
 */
export interface Class<T> {
    new(...args: Array<any>): T;
}

/**
 * The global DB object to use.
 */
export const db: baqend;

export default db;

/**
 * <p>Creates a new Acl object, with an empty rule set for an object</p>
 */
export class Acl {
  constructor(metadata?: util.Metadata);
  readonly read: util.Permission;
  readonly write: util.Permission;
  /** <p>Removes all acl rules, read and write access is public afterwards</p> */
  clear(): void;
  /** <p>Copies permissions from another ACL</p> */
  copy(acl: Acl): Acl;
  /** <p>Gets whenever all users and roles have the permission to read the object</p> */
  isPublicReadAllowed(): boolean;
  /** <p>Sets whenever all users and roles should have the permission to read the object</p> <p>Note: All other allow read rules will be removed.</p> */
  setPublicReadAllowed(): void;
  /** <p>Checks whenever the user or role is explicit allowed to read the object</p> */
  isReadAllowed(userOrRole: model.User | model.Role | string): boolean;
  /** <p>Checks whenever the user or role is explicit denied to read the object</p> */
  isReadDenied(userOrRole: model.User | model.Role | string): boolean;
  /** <p>Allows the given user or rule to read the object</p> */
  allowReadAccess(...userOrRole: (model.User | model.Role | string)[]): Acl;
  /** <p>Denies the given user or rule to read the object</p> */
  denyReadAccess(...userOrRole: (model.User | model.Role | string)[]): Acl;
  /** <p>Deletes any read allow/deny rule for the given user or role</p> */
  deleteReadAccess(...userOrRole: (model.User | model.Role | string)[]): Acl;
  /** <p>Gets whenever all users and roles have the permission to write the object</p> */
  isPublicWriteAllowed(): boolean;
  /** <p>Sets whenever all users and roles should have the permission to write the object</p> <p>Note: All other allow write rules will be removed.</p> */
  setPublicWriteAllowed(): void;
  /** <p>Checks whenever the user or role is explicit allowed to write the object</p> */
  isWriteAllowed(userOrRole: model.User | model.Role | string): boolean;
  /** <p>Checks whenever the user or role is explicit denied to write the object</p> */
  isWriteDenied(userOrRole: model.User | model.Role | string): boolean;
  /** <p>Allows the given user or rule to write the object</p> */
  allowWriteAccess(...userOrRole: (model.User | model.Role | string)[]): Acl;
  /** <p>Denies the given user or rule to write the object</p> */
  denyWriteAccess(...userOrRole: (model.User | model.Role | string)[]): Acl;
  /** <p>Deletes any write allow/deny rule for the given user or role</p> */
  deleteWriteAccess(...userOrRole: (model.User | model.Role | string)[]): Acl;
  /** <p>A JSON representation of the set of rules</p> */
  toJSON(): json;
  /** <p>Sets the acl rules form JSON</p> */
  fromJSON(json: json): void;
}

export class EntityManager extends util.Lockable {
  constructor(entityManagerFactory: EntityManagerFactory);
  readonly isOpen: boolean;
  token: string;
  readonly isCachingDisabled: boolean;
  readonly isDeviceRegistered: boolean;
  readonly log: util.Logger;
  readonly entityManagerFactory: EntityManagerFactory;
  readonly metamodel: metamodel.Metamodel;
  readonly code: util.Code;
  readonly modules: util.Modules;
  readonly me: model.User | null;
  readonly deviceMe: model.Device | null;
  readonly tokenStorage: util.TokenStorage;
  readonly bloomFilter: caching.BloomFilter;
  readonly bloomFilterRefresh: number;
  /** <p>Connects this entityManager, used for synchronous and asynchronous initialization</p> */
  connected(connector: connector.Connector, connectData: object, tokenStorage: util.TokenStorage): void;
  /** <p>Get an instance whose state may be lazily fetched</p> <p>If the requested instance does not exist in the database, the<br>EntityNotFoundError is thrown when the instance state is first accessed.<br>The application should not expect that the instance state will be available upon detachment,<br>unless it was accessed by the application while the entity manager was open.</p> */
  getReference(entityClass: Class<binding.Entity> | string, key?: string): binding.Entity;
  /** <p>Creates an instance of {@link query.Builder<T>} for query creation and execution</p> <p>The query results are instances of the resultClass argument.</p> */
  createQueryBuilder<T>(resultClass?: Class<T>): query.Builder<T>;
  /** <p>Clear the persistence context, causing all managed entities to become detached</p> <p>Changes made to entities that have not been flushed to the database will not be persisted.</p> */
  clear(): void;
  /** <p>Close an application-managed entity manager</p> <p>After the close method has been invoked, all methods on the EntityManager instance<br>and any Query and TypedQuery objects obtained from it will throw the IllegalStateError<br>except for transaction, and isOpen (which will return false). If this method<br>is called when the entity manager is associated with an active transaction,<br>the persistence context remains managed until the transaction completes.</p> */
  close(): void;
  /** <p>Check if the instance is a managed entity instance belonging to the current persistence context</p> */
  contains(entity: binding.Entity): boolean;
  /** <p>Check if an object with the id from the given entity is already attached</p> */
  containsById(entity: binding.Entity): boolean;
  /** <p>Remove the given entity from the persistence context, causing a managed entity to become detached</p> <p>Unflushed changes made to the entity if any (including removal of the entity),<br>will not be synchronized to the database. Entities which previously referenced the detached entity will continue<br>to reference it.</p> */
  detach(entity: binding.Entity): Promise<binding.Entity>;
  /** <p>Resolve the depth by loading the referenced objects of the given entity</p> */
  resolveDepth(entity: binding.Entity, options?: object): Promise<binding.Entity>;
  /** <p>Search for an entity of the specified oid</p> <p>If the entity instance is contained in the persistence context, it is returned from there.</p> */
  load(entityClass: Class<binding.Entity> | string, oid: String, options?: object): Promise<binding.Entity>;
  insert(entity: binding.Entity, options: object): Promise<binding.Entity>;
  update(entity: binding.Entity, options: object): Promise<binding.Entity>;
  save(entity: binding.Entity, options: object, withoutLock?: boolean): Promise<binding.Entity>;
  optimisticSave(entity: binding.Entity, cb: Function): Promise<binding.Entity>;
  /** <p>Returns all referenced sub entities for the given depth and root entity</p> */
  getSubEntities(entity: binding.Entity, depth: boolean | number, resolved?: binding.Entity[], initialEntity?: binding.Entity): binding.Entity[];
  /** <p>Returns all referenced one level sub entities for the given path</p> */
  getSubEntitiesByPath(entity: binding.Entity, path: string[]): binding.Entity[];
  /** <p>Delete the entity instance.</p> */
  delete(entity: binding.Entity, options: object): Promise<binding.Entity>;
  /** <p>Synchronize the persistence context to the underlying database.</p> */
  flush(): Promise<any>;
  /** <p>Make an instance managed and persistent.</p> */
  persist(entity: binding.Entity): void;
  /** <p>Refresh the state of the instance from the database, overwriting changes made to the entity, if any.</p> */
  refresh(entity: binding.Entity, options: object): Promise<binding.Entity>;
  /** <p>Attach the instance to this database context, if it is not already attached</p> */
  attach(entity: binding.Entity): void;
  /** <p>Opens a new window use for OAuth logins</p> */
  openOAuthWindow(url: string, targetOrTitle: string, options: object): void;
  registerDevice(devicetype: string, subscription: object, device: model.Device): Promise<model.Device>;
  /** <p>The given entity will be checked by the validation code of the entity type.</p> */
  validate(entity: binding.Entity): util.ValidationResult;
  /** <p>Adds the given object id to the cacheWhiteList if needed.</p> */
  addToWhiteList(objectId: string): void;
  /** <p>Adds the given object id to the cacheBlackList if needed.</p> */
  addToBlackList(objectId: string): void;
  /** <p>Checks the freshness of the bloom filter and does a reload if necessary</p> */
  ensureBloomFilterFreshness(): void;
  /** <p>Checks for a given id, if revalidation is required, the resource is stale or caching was disabled</p> */
  mustRevalidate(id: string): boolean;
  ensureCacheHeader(id: string, message: connector.Message, refresh: boolean): void;
  /** <p>Creates a absolute url for the given relative one</p> */
  createURL(relativePath: string, authorize?: boolean): string;
  /** <p>Requests a perpetual token for the given user</p> <p>Only users with the admin role are allowed to request an API token.</p> */
  requestAPIToken(entityClass: Class<binding.Entity> | Class<binding.Managed>, user: binding.User | String): Promise<any>;
  /** <p>Revoke all created tokens for the given user</p> <p>This method will revoke all previously issued tokens and the user must login again.</p> */
  revokeAllTokens(entityClass: Class<binding.Entity> | Class<binding.Managed>, user: binding.User | String): Promise<any>;
  /** <p>Constructor for a new List collection</p> */
  List<U>(...args: U[]): U[];
  /** <p>Constructor for a new Set collection</p> */
  Set<U>(collection?: Iterable<U>): Set<U>;
  /** <p>Constructor for a new Map collection</p> */
  Map(collection?: Iterable<any>): Map<any, any>;
  /** <p>Constructor for a new GeoPoint</p> */
  GeoPoint(latitude?: string | number | number[], longitude?: number): GeoPoint;
  User: binding.UserFactory;
  Role: binding.EntityFactory<model.Role>;
  Device: binding.DeviceFactory;
  [YourEntityClass: string]: any;
  File: binding.FileFactory;
}

/**
 * <p>Creates a new EntityManagerFactory connected to the given destination</p>
 */
export class EntityManagerFactory extends util.Lockable {
  constructor(options?: string | { host?: string, port?: number, secure?: boolean, basePath?: string, schema?: object, tokenStorage?: util.TokenStorage, tokenStorageFactory?: util.TokenStorageFactory, staleness?: number });
  connection: connector.Connector;
  metamodel: metamodel.Metamodel;
  code: util.Code;
  tokenStorageFactory: util.TokenStorageFactory;
  /** <p>Apply additional configurations to this EntityManagerFactory</p> */
  configure(options: { tokenStorage?: util.TokenStorage, tokenStorageFactory?: util.TokenStorageFactory, staleness?: number }): void;
  tokenStorage: util.TokenStorage;
  staleness: number;
  /** <p>Connects this EntityManager to the given destination</p> */
  connect(hostOrApp: string, port?: number, secure?: boolean, basePath?: string): Promise<this>;
  /** <p>Connects this EntityManager to the given destination</p> */
  connect(hostOrApp: string, secure?: boolean): Promise<this>;
  /** <p>Creates a new Metamodel instance, which is not connected</p> */
  createMetamodel(): metamodel.Metamodel;
  /** <p>Create a new application-managed EntityManager.</p> */
  createEntityManager(useSharedTokenStorage?: boolean): EntityManager;
}

/**
 * <p>Creates a new GeoPoint instance<br>From latitude and longitude<br>From a json object<br>Or an tuple of latitude and longitude</p>
 */
export class GeoPoint {
  constructor(latitude?: string | number | number[], longitude?: number);
  /** <p>Creates a GeoPoint with the user's current location, if available.</p> */
  static current(): Promise<GeoPoint>;
  longitude: number;
  latitude: number;
  /** <p>Returns the distance from this GeoPoint to another in kilometers.</p> */
  kilometersTo(point: GeoPoint): number;
  /** <p>Returns the distance from this GeoPoint to another in miles.</p> */
  milesTo(point: GeoPoint): number;
  /** <p>Computes the arc, in radian, between two WGS-84 positions.</p> <p>The haversine formula implementation is taken from:<br>{@link http://<a href="http://www.movable-type.co.uk/scripts/latlong.html}">www.movable-type.co.uk/scripts/latlong.html}</a></p> <p>Returns the distance from this GeoPoint to another in radians.</p> */
  radiansTo(point: GeoPoint): number;
  /** <p>A String representation in latitude, longitude format</p> */
  toString(): string;
  /** <p>Returns a JSON representation of the GeoPoint</p> */
  toJSON(): json;
  static DEG_TO_RAD: number;
  static EARTH_RADIUS_IN_KILOMETERS: number;
  static EARTH_RADIUS_IN_MILES: number;
}

export interface baqend extends EntityManager {
  /** <p>Configures the DB with additional config options</p> */
  configure(options: { tokenStorage?: util.TokenStorage, tokenStorageFactory?: util.TokenStorageFactory, staleness?: number }): baqend;
  /** <p>Connects the DB with the server and calls the callback on success</p> */
  connect(hostOrApp: string, secure?: boolean, doneCallback?: (entity: this) => Promise<any> | any, failCallback?: (error: Error) => Promise<any> | any): Promise<EntityManager>;
}

/**
 * <p>An event for a real-time query.</p>
 */
export class RealtimeEvent<T> {
  constructor();
  target: query.Node<T>;
  data: T;
  operation: string;
  matchType: string;
  initial: boolean;
  index: number;
  date: Date;
}

export namespace binding {

  /**
   * <p>Adds a trailing slash to a string if it is missing</p>
   */
  export function trailingSlashIt(str: string): string;

  export class Accessor {
    constructor();
    getValue(object: object, attribute: metamodel.Attribute): any;
    setValue(object: object, attribute: metamodel.Attribute, value: any): void;
  }

  export interface DeviceFactory extends binding.EntityFactory<model.Device> {
    readonly me: model.Device;
    readonly isRegistered: boolean;
    /** <p>Loads the Public VAPID Key which can be used to subscribe a Browser for Web Push notifications</p> */
    loadWebPushKey(): Promise<ArrayBuffer>;
    /** <p>Register a new device with the given device token and OS.</p> */
    register(os: string, tokenOrSubscription: string | Subscription, doneCallback: (entity: this) => Promise<any> | any, failCallback?: (error: error.PersistentError) => Promise<any> | any): Promise<model.Device>;
    /** <p>Register a new device with the given device token and OS.</p> */
    register(os: string, tokenOrSubscription: string | PushSubscription, device?: model.Device, doneCallback?: (entity: this) => Promise<any> | any, failCallback?: (error: error.PersistentError) => Promise<any> | any): Promise<model.Device>;
    /** <p>Uses the info from the given {util.PushMessage} message to send an push notification.</p> */
    push(pushMessage: util.PushMessage, doneCallback?: (entity: this) => Promise<any> | any, failCallback?: (error: error.PersistentError) => Promise<any> | any): Promise<any>;
    /** <p>Push message will be used to send a push notification to a set of devices</p> */
    PushMessage(devices?: Set<binding.Entity> | binding.Entity[], message?: string, subject?: string, sound?: string, badge?: number, data?: object): util.PushMessage;
  }

  export class Enhancer {
    constructor();
    createProxy(superClass: Class<any>): Class<any>;
    static getBaqendType(typeConstructor: Class<any>): metamodel.ManagedType;
    static getIdentifier(typeConstructor: Class<any>): string;
    static setIdentifier(typeConstructor: Class<any>, identifier: string): void;
    enhance(type: metamodel.ManagedType, typeConstructor: Class<any>): void;
    /** <p>Enhance the prototype of the type</p> */
    enhancePrototype(proto: object, type: metamodel.ManagedType): void;
    enhanceProperty(proto: object, attribute: metamodel.Attribute): void;
  }

  export class Entity extends binding.Managed {
    constructor();
    id: string;
    key: string;
    readonly version: number;
    readonly acl: Acl;
    readonly createdAt: Date;
    readonly updatedAt: Date;
    /** <p>Waits on the previously requested operation on this object completes</p> */
    ready(doneCallback?: (entity: this) => Promise<any> | any): Promise<this>;
    /** <p>Attach this object to the given db</p> */
    attach(db: EntityManager): void;
    /** <p>Saves the object. Inserts the object if it doesn't exists and updates the object if the object exist.</p> */
    save(options?: { force?: boolean, depth?: number | boolean, refresh?: boolean }, doneCallback?: (entity: this) => Promise<any> | any, failCallback?: (error: error.PersistentError) => Promise<any> | any): Promise<this>;
    /** <p>Inserts a new object. Inserts the object if it doesn't exists and raise an error if the object already exist.</p> */
    insert(options?: { depth?: number | boolean, refresh?: boolean }, doneCallback?: (entity: this) => Promise<any> | any, failCallback?: (error: error.PersistentError) => Promise<any> | any): Promise<this>;
    /** <p>Updates an existing object</p> <p>Updates the object if it exists and raise an error if the object doesn't exist.</p> */
    update(options?: { force?: boolean, depth?: number | boolean, refresh?: boolean }, doneCallback?: (entity: this) => Promise<any> | any, failCallback?: (error: error.PersistentError) => Promise<any> | any): Promise<this>;
    /** <p>Resolves the referenced object in the specified depth</p> <p>Only unresolved objects will be loaded unless the refresh option is specified.</p> <p>Removed objects will be marked as removed.</p> */
    load(options?: { depth?: number | boolean, refresh?: boolean }, doneCallback?: (entity: this) => Promise<any> | any, failCallback?: (error: error.PersistentError) => Promise<any> | any): Promise<this>;
    /** <p>Deletes an existing object</p> */
    delete(options?: { force?: boolean, depth?: number | boolean }, doneCallback?: (entity: this) => Promise<any> | any, failCallback?: (error: error.PersistentError) => Promise<any> | any): Promise<this>;
    /** <p>Saves the object and repeats the operation if the object is out of date</p> <p>In each pass the callback will be called. Ths first parameter of the callback is the entity and the second one<br>is a function to abort the process.</p> */
    optimisticSave(cb: Function, doneCallback?: (entity: this) => Promise<any> | any, failCallback?: (error: error.PersistentError) => Promise<any> | any): Promise<this>;
    /** <p>Validates the entity by using the validation code of the entity type</p> */
    validate(): util.ValidationResult;
    /** <p>Starts a partial update on this entity</p> */
    partialUpdate(operations?: json): partialupdate.EntityPartialUpdateBuilder<this>;
    /** <p>Get all objects which refer to this object</p> */
    getReferencing(options?: { classes?: string[] }): Promise<binding.Entity>;
    /** <p>Converts the object to an JSON-Object</p> */
    toJSON(options?: boolean | { excludeMetadata?: boolean, depth?: number | boolean }): json;
  }

  export interface EntityFactory<T> extends binding.ManagedFactory<T> {
    /** <p>Loads the instance for the given id, or null if the id does not exists.</p> */
    load(id: string, options?: { depth?: number | boolean, refresh?: boolean, local?: boolean }, doneCallback?: (entity: T) => Promise<any> | any, failCallback?: (error: error.PersistentError) => Promise<any> | any): Promise<T>;
    /** <p>Gets an unloaded reference for the given id.</p> */
    ref(id: string): T;
    /** <p>Creates a new instance and sets the DatabaseObject to the given json</p> */
    fromJSON(json: json): T;
    /** <p>Creates a new query for this class</p> */
    find(): query.Builder<T>;
    /** <p>Creates a new partial update for this class</p> */
    partialUpdate(id: string, partialUpdate?: json): partialupdate.EntityPartialUpdateBuilder<T>;
  }

  /**
   * <p>This factory creates instances of type T, by invoking the {@link #new()} method<br>or by instantiating this factory directly</p>
   */
  export interface Factory<T> {
    /** <p>Creates a new instance of the factory type</p> */
    new(...args: any[]): T;
    /** <p>Creates a new instance of the factory type</p> */
    newInstance(args?: any[]): T;
  }

  /**
   * <p>Creates a file object, which represents one specific file reference.<br>This File object can afterwards be used to up- and download the file contents or to retrieves and change the files<br>metadata.</p>
   * <p>The file data can be uploaded and downloaded as:</p>
   * <table class="table"><br>  <tr><br>    <th>type</th><br>    <th>JavaScript type</th><br>    <th>Description</th><br>  </tr><br>  <tr><br>    <td>'arraybuffer'</td><br>    <td>ArrayBuffer</td><br>    <td>The content is represented as a fixed-length raw binary data buffer</td><br>  </tr><br>  <tr><br>    <td>'blob'</th><br>    <td>Blob</td><br>    <td>The content is represented as a simple blob</td><br>  </tr><br>  <tr><br>    <td>'json'</td><br>    <td>object|array|string</td><br>    <td>The file content is represented as json</td><br>  </tr><br>  <tr><br>    <td>'text'</td><br>    <td>string</td><br>    <td>The file content is represented through the string</td><br>  </tr><br>  <tr><br>    <td>'base64'</td><br>    <td>string</td><br>    <td>The file content as base64 encoded string</td><br>  </tr><br>  <tr><br>    <td>'data-url'</td><br>    <td>string</td><br>    <td>A data url which represents the file content</td><br>  </tr><br></table>
   */
  export class File {
    constructor(fileOptions: string | { id?: string, name?: string, parent?: string, path?: string, data: string | Blob | File | ArrayBuffer | json, type?: string, mimeType?: string, size?: number, eTag?: string, lastModified: string | Date, acl?: Acl, headers?: { [key: string]: string } });
    readonly id: string;
    readonly url: string;
    readonly name: string;
    readonly mimeType: string;
    readonly acl: Acl;
    readonly lastModified?: Date;
    readonly createdAt?: Date;
    readonly eTag: string;
    readonly headers: { [key: string]: string };
    readonly size: number;
    readonly bucket: string;
    readonly key: string;
    readonly path: string;
    readonly parent: string;
    readonly isMetadataLoaded: boolean;
    readonly isFolder: boolean;
    /** <p>Parses an E-Tag header</p> */
    static parseETag(eTag?: string): string;
    /** <p>Uploads the file content which was provided in the constructor or by uploadOptions.data</p> */
    upload(uploadOptions?: { data?: string | Blob | File | ArrayBuffer | json, type?: string, mimeType?: string, eTag?: string, lastModified?: string, acl?: Acl, headers?: { [key: string]: string }, force?: boolean, progress?: (event: ProgressEvent) => any }, doneCallback?: (file: binding.File) => any, failCallback?: (error: error.PersistentError) => any): Promise<binding.File>;
    /** <p>Download a file and providing it in the requested type</p> */
    download(downloadOptions?: { type?: string, refresh?: string }, doneCallback?: (data: string | Blob | File | ArrayBuffer | json) => any, failCallback?: (error: error.PersistentError) => any): Promise<(string|Blob|File|ArrayBuffer|json)>;
    /** <p>Deletes a file</p> */
    delete(deleteOptions?: { force?: boolean }, doneCallback?: (data: binding.File) => any, failCallback?: (error: error.PersistentError) => any): Promise<(binding.File|Array<binding.File>)>;
    /** <p>Makes the given message a conditional request based on the file metadata</p> */
    conditional(msg: connector.Message, options: { force?: boolean }): void;
    /** <p>Gets the file metadata of a file</p> */
    loadMetadata(options?: { refresh?: boolean }, doneCallback?: (file: binding.File) => any, failCallback?: (error: error.PersistentError) => any): Promise<binding.File>;
    /** <p>Updates the matadata of this file.</p> */
    saveMetadata(options?: { force?: boolean }, doneCallback?: (file: binding.File) => any, failCallback?: (error: error.PersistentError) => any): Promise<binding.File>;
    /** <p>Deserialize the given JSON file metadata back to this file instance</p> <p>If the JSON object contains an ID, it must match with this file ID, otherwise an exception is thrown.</p> */
    fromJSON(json: json): void;
    /** <p>Serialize the file metadata of this object to json</p> */
    toJSON(): json;
    /** <p>Checks whenever metadata are already loaded of the file, throws an error otherwise</p> */
    checkAvailable(): void;
  }

  export interface FileFactory extends binding.Factory<binding.File> {
    /** <p>Creates a new FileFactory for the given type</p> */
    create(db: EntityManager): binding.FileFactory;
    /** <p>Creates a new file</p> */
    newInstance(args?: any[]): binding.File;
    /** <p>Deserialize the file metadata from a json object back to a new file instance</p> */
    fromJSON(json: json): binding.File;
    /** <p>Updates the metadata of the root file directory formally the file &quot;bucket&quot;</p> */
    saveMetadata(bucket: string, metadata: { [key: string]: util.Permission } | { load?: util.Permission, insert?: util.Permission, update?: util.Permission, delete?: util.Permission, query?: util.Permission }, doneCallback?: (bucketMetadata: { [key: string]: util.Permission }) => any, failCallback?: (error: error.PersistentError) => any): Promise<void>;
    /** <p>Gets the metadata of the root folder (formally the file &quot;bucket&quot;)</p> */
    loadMetadata(bucket: string, options?: { refresh?: object }, doneCallback?: (bucketMetadata: { [key: string]: util.Permission }) => any, failCallback?: (error: error.PersistentError) => any): Promise<{ [key: string]: util.Permission }>;
    /** <p>Lists all the buckets.</p> */
    listBuckets(doneCallback?: (files: binding.File[]) => any, failCallback?: (error: error.PersistentError) => any): Promise<binding.File[]>;
    /** <p>Lists the files (and folders) in the given folder.</p> */
    listFiles(folderOrPath: binding.File | string, start: binding.File, count: number, doneCallback?: (files: binding.File[]) => any, failCallback?: (error: error.PersistentError) => any): Promise<binding.File[]>;
    /** <p>Creates a new file object which represents the file at the given ID</p> <p>Data provided to the constructor will be uploaded by invoking {@link upload()}.</p> */
    new(fileOptions: string | { name?: string, parent?: string, data: string | Blob | File | ArrayBuffer | json, type?: string, mimeType?: string, eTag?: string, lastModified?: string, acl?: Acl, headers?: { [key: string]: string } }): binding.File;
  }

  /**
   * <p>The default constructor, copy all given properties to this object</p>
   */
  export class Managed {
    constructor(properties?: { [key: string]: any });
    /** <p>Initialize the given instance</p> */
    static init(instance: binding.Managed, properties?: { [key: string]: any }): void;
    /** <p>Creates a subclass of this class</p> */
    static extend(childClass: Class<any>): Class<any>;
    /** <p>Converts the managed object to an JSON-Object.</p> */
    toJSON(): json;
  }

  export interface ManagedFactory<T> extends binding.Factory<T> {
    /** <p>Creates a new instance of the factory type</p> */
    newInstance(args?: any[]): T;
    /** <p>Creates a new instance and sets the Managed Object to the given json</p> */
    fromJSON(json: json): T;
    /** <p>Adds methods to instances of this factories type</p> */
    addMethods(methods: { [key: string]: Function }): void;
    /** <p>Add a method to instances of this factories type</p> */
    addMethod(name: string, fn: Function): void;
    methods: { [key: string]: Function };
    readonly managedType: metamodel.ManagedType;
    readonly db: EntityManager;
    /** <p>Creates a new instance of the of this type</p> */
    new(properties: { [key: string]: any }): T;
  }

  export class Role extends binding.Entity {
    constructor();
    /** <p>Test if the given user has this role</p> */
    hasUser(user: model.User): boolean;
    /** <p>Add the given user to this role</p> */
    addUser(user: model.User): void;
    /** <p>Remove the given user from this role</p> */
    removeUser(user: model.User): void;
    users: Set<model.User>;
    name: string;
  }

  export class User extends binding.Entity {
    constructor();
    /** <p>Change the password of the given user</p> */
    newPassword(currentPassword: string, password: string, doneCallback?: (entity: this) => Promise<any> | any, failCallback?: (error: error.PersistentError) => Promise<any> | any): Promise<model.User>;
    /** <p>Change the username of the current user</p> */
    changeUsername(newUsername: string, password: string, doneCallback?: (entity: this) => Promise<any> | any, failCallback?: (error: error.PersistentError) => Promise<any> | any): Promise<any>;
    /** <p>Requests a perpetual token for the user</p> <p>Only users with the admin role are allowed to request an API token.</p> */
    requestAPIToken(doneCallback?: (entity: this) => Promise<any> | any, failCallback?: (error: error.PersistentError) => Promise<any> | any): Promise<any>;
    username: string;
    inactive: boolean;
  }

  export interface UserFactory extends binding.EntityFactory<model.User> {
    readonly me: model.User;
    /** <p>Register a new user with the given username and password, if the username is not used by an another user.</p> */
    register(user: string | model.User, password: string, loginOption?: boolean | binding.UserFactory.LoginOption, doneCallback?: (entity: this) => Promise<any> | any, failCallback?: (error: error.PersistentError) => Promise<any> | any): Promise<model.User>;
    /** <p>Log in the user with the given username and password and starts a user session</p> */
    login(username: string, password: string, loginOption?: boolean | binding.UserFactory.LoginOption, doneCallback?: (entity: this) => Promise<any> | any, failCallback?: (error: error.PersistentError) => Promise<any> | any): Promise<model.User>;
    /** <p>Log in the user assiciated with the given token and starts a user session.</p> */
    loginWithToken(token: string, loginOption?: boolean | binding.UserFactory.LoginOption, doneCallback?: (entity: this) => Promise<any> | any, failCallback?: (error: error.PersistentError) => Promise<any> | any): Promise<model.User>;
    /** <p>Log out the current logged in user and ends the active user session</p> */
    logout(doneCallback?: (entity: this) => Promise<any> | any, failCallback?: (error: error.PersistentError) => Promise<any> | any): Promise<any>;
    /** <p>Change the password of the given user</p> */
    newPassword(username: string, password: string, newPassword: string, doneCallback?: (entity: this) => Promise<any> | any, failCallback?: (error: error.PersistentError) => Promise<any> | any): Promise<model.User>;
    /** <p>Sends an email with a link to reset the password for the given username</p> <p>The username must be a valid email address.</p> */
    resetPassword(username: string, doneCallback?: (entity: this) => Promise<any> | any, failCallback?: (error: error.PersistentError) => Promise<any> | any): Promise<any>;
    /** <p>Sends an email with a link to change the current username</p> <p>The user is identified by their current username and password.<br>The username must be a valid email address.</p> */
    changeUsername(username: string, newUsername: string, password: string, doneCallback?: (entity: this) => Promise<any> | any, failCallback?: (error: error.PersistentError) => Promise<any> | any): Promise<any>;
    /** <p>Requests a perpetual token for the given user</p> <p>Only users with the admin role are allowed to request an API token.</p> */
    requestAPIToken(user: binding.User | String, doneCallback?: (entity: this) => Promise<any> | any, failCallback?: (error: error.PersistentError) => Promise<any> | any): Promise<any>;
    /** <p>Revoke all created tokens for the given user</p> <p>This method will revoke all previously issued tokens and the user must login again.</p> */
    revokeAllTokens(user: binding.User | String, doneCallback?: (entity: this) => Promise<any> | any, failCallback?: (error: error.PersistentError) => Promise<any> | any): Promise<any>;
    /** <p>Change the password of a user, which will be identified by the given token from the reset password e-mail</p> */
    newPassword(token: string, newPassword: string, loginOption?: boolean | binding.UserFactory.LoginOption, doneCallback?: (entity: this) => Promise<any> | any, failCallback?: (error: error.PersistentError) => Promise<any> | any): Promise<model.User>;
    /** <p>Logs the user in with Google via OAuth</p> <p>Prompts the user for the Google login in a new window. Before using OAuth you need to setup your application<br>on the provider website, add the redirect uri: <code>https://example.net/db/User/OAuth/google</code> and copy the<br>client id and the client secret to your Baqend dashboard settings. When the returned promise succeeds the user is<br>logged in.</p> */
    loginWithGoogle(clientID: string, options?: { title?: string, width?: number, height?: number, scope?: string, state?: object, timeout?: number, redirect?: string }, loginOption?: boolean | binding.UserFactory.LoginOption, doneCallback?: (entity: this) => Promise<any> | any, failCallback?: (error: error.PersistentError) => Promise<any> | any): Promise<model.User>;
    /** <p>Logs the user in with Facebook via OAuth</p> <p>Prompts the user for the Facebook login in a new window. Before using OAuth you need to setup your application<br>on the provider website, add the redirect uri: https://example.net/db/User/OAuth/facebook and copy the client id<br>and the client secret to your Baqend dashboard settings. When the returned promise succeeds the user is logged in.</p> */
    loginWithFacebook(clientID: string, options?: { title?: string, width?: number, height?: number, scope?: string, state?: object, timeout?: number, redirect?: string }, loginOption?: boolean | binding.UserFactory.LoginOption, doneCallback?: (entity: this) => Promise<any> | any, failCallback?: (error: error.PersistentError) => Promise<any> | any): Promise<model.User>;
    /** <p>Logs the user in with GitHub via OAuth</p> <p>Prompts the user for the GitHub login in a new window. Before using OAuth you need to setup your application<br>on the provider website, add the redirect uri: https://example.net/db/User/OAuth/github and copy the client id<br>and the client secret to your Baqend dashboard settings. When the returned promise succeeds the user is logged in.</p> */
    loginWithGitHub(clientID: string, options?: { title?: string, width?: number, height?: number, scope?: string, state?: object, timeout?: number, redirect?: string }, loginOption?: boolean | binding.UserFactory.LoginOption, doneCallback?: (entity: this) => Promise<any> | any, failCallback?: (error: error.PersistentError) => Promise<any> | any): Promise<model.User>;
    /** <p>Logs the user in with Twitter via OAuth</p> <p>Prompts the user for the Twitter login in a new window. Before using OAuth you need to setup your application<br>on the provider website, add the redirect uri: https://example.net/db/User/OAuth/twitter and copy the client id<br>and the client secret to your Baqend dashboard settings. When the returned promise succeeds the user is logged in.</p> */
    loginWithTwitter(clientID: string, options?: { title?: string, width?: number, height?: number, timeout?: number, redirect?: string }, loginOption?: boolean | binding.UserFactory.LoginOption, doneCallback?: (entity: this) => Promise<any> | any, failCallback?: (error: error.PersistentError) => Promise<any> | any): Promise<model.User>;
    /** <p>Logs the user in with LinkedIn via OAuth</p> <p>Prompts the user for the LinkedIn login in a new window. Before using OAuth you need to setup your application<br>on the provider website, add the redirect uri: https://example.net/db/User/OAuth/linkedin and copy the client id<br>and the client secret to your Baqend dashboard settings. When the returned promise succeeds the user is logged in.</p> */
    loginWithLinkedIn(clientID: string, options?: { title?: string, width?: number, height?: number, scope?: string, state?: object, timeout?: number, redirect?: string }, loginOption?: boolean | binding.UserFactory.LoginOption, doneCallback?: (entity: this) => Promise<any> | any, failCallback?: (error: error.PersistentError) => Promise<any> | any): Promise<model.User>;
    /** <p>Logs the user in with Salesforce via OAuth</p> <p>Prompts the user for the Salesforce login in a new window. Before using OAuth you need to setup your application<br>on the provider website, add the redirect uri: <code>https://example.net/db/User/OAuth/salesforce</code> and copy the<br>client id and the client secret to your Baqend dashboard settings. When the returned promise succeeds the user is<br>logged in.</p> */
    loginWithSalesforce(clientID: string, options?: { title?: string, width?: number, height?: number, scope?: string, state?: object, timeout?: number, redirect?: string, path?: object }, loginOption?: boolean | binding.UserFactory.LoginOption, doneCallback?: (entity: this) => Promise<any> | any, failCallback?: (error: error.PersistentError) => Promise<any> | any): Promise<model.User>;
    /** <p>Creates a new user object</p> */
    new(properties: { [key: string]: any }): model.User;
  }

  export namespace UserFactory {

    export enum LoginOption {
      NO_LOGIN = -1,
      SESSION_LOGIN = 0,
      PERSIST_LOGIN = 1,
    }
  }
}

export namespace caching {

  /**
   * <p>A Bloom Filter is a client-side kept cache sketch of the server cache</p>
   */
  export class BloomFilter {
    constructor(bloomFilter: { m: number, h: number, b: string });
    readonly bytes: string;
    readonly bits: number;
    readonly hashes: number;
    readonly creation: number;
    /** <p>Returns whether this Bloom filter contains the given element.</p> */
    contains(element: string): boolean;
  }
}

export namespace connector {

  export class Connector {
    constructor(host: string, port: number, secure: boolean, basePath: string);
    static create(host: string, port?: number, secure?: boolean, basePath?: string): connector.Connector;
    readonly host: string;
    readonly port: number;
    readonly secure: boolean;
    readonly basePath: string;
    readonly origin: string;
    send(message: connector.Message): Promise<connector.Message>;
    prepareRequest(message: connector.Message): void;
    /** <p>Convert the message entity to the sendable representation</p> */
    toFormat(message: connector.Message): void;
    prepareResponse(message: connector.Message, response: object): Promise<any>;
    /** <p>Convert received data to the requested response entity type</p> */
    fromFormat(response: object, entity: any, type: string): any;
    static RESPONSE_HEADERS: string[];
    static connectors: connector.Connector[];
    static connections: { [key: string]: connector.Connector };
  }

  export class FetchConnector extends connector.Connector {
    constructor();
    /** <p>Indicates if this connector implementation is usable for the given host and port</p> */
    static isUsable(): boolean;
  }

  export class IFrameConnector extends connector.XMLHttpConnector {
    constructor();
    /** <p>Indicates if this connector implementation is usable for the given host and port</p> */
    static isUsable(host: string, port: number, secure: boolean): boolean;
  }

  export class Message {
    constructor();
    /** <p>Creates a new message class with the given message specification</p> */
    static create(specification: object): Class<Message>;
    /** <p>Creates a new message class with the given message specification and a full path</p> */
    static createExternal(specification: object, members: object): Class<Message>;
    withCredentials: boolean;
    tokenStorage: util.TokenStorage;
    progressCallback: (event: ProgressEvent) => any;
    /** <p>Gets the request path</p> */
    path(): string;
    /** <p>Sets the request path</p> */
    path(path: string): this;
    /** <p>Gets the value of a the specified request header</p> */
    header(name: string): string;
    /** <p>Sets the value of a the specified request header</p> */
    header(name: string, value: string): this;
    /** <p>Sets the entity type</p> */
    entity(data: any, type?: 'json' | 'text' | 'blob' | 'buffer' | 'arraybuffer' | 'data-url' | 'form'): this;
    /** <p>Get the mimeType</p> */
    mimeType(): string;
    /** <p>Sets the mimeType</p> */
    mimeType(mimeType: string): this;
    /** <p>Gets the contentLength</p> */
    contentLength(): number;
    /** <p>Sets the contentLength</p> */
    contentLength(contentLength: number): this;
    /** <p>Gets the request conditional If-Match header</p> */
    ifMatch(): string;
    /** <p>Sets the request conditional If-Match header</p> */
    ifMatch(eTag: string): this;
    /** <p>Gets the request a ETag based conditional header</p> */
    ifNoneMatch(): string;
    /** <p>Sets the request a ETag based conditional header</p> */
    ifNoneMatch(eTag: string): this;
    /** <p>Gets the request date based conditional header</p> */
    ifUnmodifiedSince(): string;
    /** <p>Sets the request date based conditional header</p> */
    ifUnmodifiedSince(date: Date): this;
    /** <p>Indicates that the request should not be served by a local cache</p> */
    noCache(): this;
    /** <p>Gets the cache control header</p> */
    cacheControl(): string;
    /** <p>Sets the cache control header</p> */
    cacheControl(value: string): this;
    /** <p>Gets the ACL of a file into the Baqend-Acl header</p> */
    acl(): string;
    /** <p>Sets and encodes the ACL of a file into the Baqend-Acl header</p> */
    acl(acl: Acl): this;
    /** <p>Gets and encodes the custom headers of a file into the Baqend-Custom-Headers header</p> */
    customHeaders(): string;
    /** <p>Sets and encodes the custom headers of a file into the Baqend-Custom-Headers header</p> */
    customHeaders(customHeaders: any): this;
    /** <p>Gets the request accept header</p> */
    accept(): string;
    /** <p>Sets the request accept header</p> */
    accept(accept: string): this;
    /** <p>Gets the response type which should be returned</p> */
    responseType(): string;
    /** <p>Sets the response type which should be returned</p> */
    responseType(type: string): this;
    /** <p>Gets the progress callback</p> */
    progress(): (event: ProgressEvent) => any;
    /** <p>Sets the progress callback</p> */
    progress(callback: (event: ProgressEvent) => any): this;
    /** <p>Adds the given string to the request path</p> <p>If the parameter is an object, it will be serialized as a query string.</p> */
    addQueryString(query: string | { [key: string]: string }): this;
    /** <p>Handle the receive</p> */
    doReceive(response: object): void;
    spec: object;
  }

  export class NodeConnector extends connector.Connector {
    constructor();
    /** <p>Parse the cookie header</p> */
    parseCookie(header: string): string | null;
  }

  export class XMLHttpConnector extends connector.Connector {
    constructor();
    /** <p>Indicates if this connector implementation is usable for the given host and port</p> */
    static isUsable(host: string, port: number, secure: boolean): boolean;
  }

  export class WebSocketConnector {
    constructor(url: String);
    static create(connector: connector.Connector, url?: String): connector.WebSocketConnector;
    openStream(tokenStorage: util.TokenStorage, id: string): connector.ObservableStream;
    static websockets: connector.Connector[];
  }

  export class ObservableStream extends Observable<connector.ChannelMessage> {
    constructor();
    /** <p>Sends a message</p> */
    send(The: connector.ChannelMessage): any;
  }

  export interface ChannelMessage {
    id: string;
    type: string;
    date: Date;
  }

  export namespace Message {

    export enum StatusCode {
      NOT_MODIFIED = 304,
      BAD_CREDENTIALS = 460,
      BUCKET_NOT_FOUND = 461,
      INVALID_PERMISSION_MODIFICATION = 462,
      INVALID_TYPE_VALUE = 463,
      OBJECT_NOT_FOUND = 404,
      OBJECT_OUT_OF_DATE = 412,
      PERMISSION_DENIED = 466,
      QUERY_DISPOSED = 467,
      QUERY_NOT_SUPPORTED = 468,
      SCHEMA_NOT_COMPATIBLE = 469,
      SCHEMA_STILL_EXISTS = 470,
      SYNTAX_ERROR = 471,
      TRANSACTION_INACTIVE = 472,
      TYPE_ALREADY_EXISTS = 473,
      TYPE_STILL_REFERENCED = 474,
      SCRIPT_ABORTION = 475,
    }
  }
}

export namespace error {

  export class CommunicationError extends error.PersistentError {
    constructor(httpMessage: connector.Message, response: object);
    name: string;
    reason: string;
    status: number;
  }

  export class EntityExistsError extends error.PersistentError {
    constructor(entity: string);
    entity: binding.Entity;
  }

  export class IllegalEntityError extends error.PersistentError {
    constructor(entity: binding.Entity);
    entity: binding.Entity;
  }

  export class PersistentError extends Error {
    constructor(message: string, cause?: Error);
  }

  export class RollbackError extends error.PersistentError {
    constructor(cause: Error);
  }
}

export namespace message {

  /**
   * <p>Get the list of all available subresources</p>
   */
  export class ListAllResources extends connector.Message {
    constructor();
  }

  /**
   * <p>Get the API version of the Orestes-Server</p>
   */
  export class ApiVersion extends connector.Message {
    constructor();
  }

  /**
   * <p>The Swagger specification of the Orestes-Server</p>
   */
  export class Specification extends connector.Message {
    constructor();
  }

  /**
   * <p>Returns all changed objects</p>
   */
  export class GetBloomFilter extends connector.Message {
    constructor();
  }

  /**
   * <p>Clears the Bloom filter (TTLs and stale entries)</p>
   */
  export class DeleteBloomFilter extends connector.Message {
    constructor();
  }

  /**
   * <p>Get the current Orestes config</p>
   */
  export class GetOrestesConfig extends connector.Message {
    constructor();
  }

  /**
   * <p>Updates the current Orestes config</p>
   */
  export class UpdateOrestesConfig extends connector.Message {
    constructor(body: json);
  }

  /**
   * <p>Connects a browser to this server</p>
   */
  export class Connect extends connector.Message {
    constructor();
  }

  /**
   * <p>Gets the status of the server health</p>
   */
  export class Status extends connector.Message {
    constructor();
  }

  /**
   * <p>Gets the event Endpoint</p>
   */
  export class EventsUrl extends connector.Message {
    constructor();
  }

  /**
   * <p>Determines whether the IP has exceeded its rate limit</p>
   */
  export class BannedIp extends connector.Message {
    constructor(ip: string);
  }

  /**
   * <p>Always returns banned status for proper CDN handling</p>
   */
  export class Banned extends connector.Message {
    constructor();
  }

  /**
   * <p>Clears all rate-limiting information for all IPs</p>
   */
  export class Unban extends connector.Message {
    constructor();
  }

  /**
   * <p>Clears rate-limiting information for given IPs</p>
   */
  export class UnbanIp extends connector.Message {
    constructor(ip: string);
  }

  /**
   * <p>List all bucket names<br>List all buckets</p>
   */
  export class GetBucketNames extends connector.Message {
    constructor();
  }

  /**
   * <p>List objects in bucket<br>List all object ids of the given bucket</p>
   */
  export class GetBucketIds extends connector.Message {
    constructor(bucket: string, start: number, count: number);
  }

  /**
   * <p>Dump objects of bucket<br>Exports the complete data set of the bucket</p>
   */
  export class ExportBucket extends connector.Message {
    constructor(bucket: string);
  }

  /**
   * <p>Upload all objects to the bucket<br>Imports the complete data set. For large uploads, this call will always return the status code 200.<br>If failures occur, they will be returned in the response body.</p>
   */
  export class ImportBucket extends connector.Message {
    constructor(bucket: string, body: json);
  }

  /**
   * <p>Delete all objects in bucket<br>Delete all objects in the given bucket</p>
   */
  export class TruncateBucket extends connector.Message {
    constructor(bucket: string);
  }

  /**
   * <p>Create object<br>Create the given object.<br>The created object will get a unique id.</p>
   */
  export class CreateObject extends connector.Message {
    constructor(bucket: string, body: json);
  }

  /**
   * <p>Get object<br>Returns the specified object. Each object has one unique identifier and therefore only one URL.</p>
   */
  export class GetObject extends connector.Message {
    constructor(bucket: string, oid: string);
  }

  /**
   * <p>Replace object<br>Replace the current object with the updated one.<br>To update a specific version of the object a version can be provided in the If-Match header.<br>The update will only be accepted, if the current version matches the provided one, otherwise the update<br>will be rejected.<br>The * wildcard matches any existing object but prevents an insertion if the object does not exist.</p>
   */
  export class ReplaceObject extends connector.Message {
    constructor(bucket: string, oid: string, body: json);
  }

  /**
   * <p>Delete object<br>Deletes the object. The If-Match Header can be used to specify an expected version. The object will<br>only be deleted if the version matches the provided one. The * wildcard can be used to match any existing<br>version but results in an error if the object does not exist.</p>
   */
  export class DeleteObject extends connector.Message {
    constructor(bucket: string, oid: string);
  }

  /**
   * <p>Get all available class schemas<br>Gets the complete schema</p>
   */
  export class GetAllSchemas extends connector.Message {
    constructor();
  }

  /**
   * <p>Create new class schemas and update existing class schemas<br>Updates the complete schema, merge all changes, reject the schema update if the schema changes aren't compatible</p>
   */
  export class UpdateAllSchemas extends connector.Message {
    constructor(body: json);
  }

  /**
   * <p>Replace all currently created schemas with the new ones<br>Replace the complete schema, with the new one.</p>
   */
  export class ReplaceAllSchemas extends connector.Message {
    constructor(body: json);
  }

  /**
   * <p>Get the class schema<br>Returns the schema definition of the class<br>The class definition contains a link to its parent class and all persistable fields with there types of the class</p>
   */
  export class GetSchema extends connector.Message {
    constructor(bucket: string);
  }

  /**
   * <p>Update the class schema<br>Modify the schema definition of the class by adding all missing fields</p>
   */
  export class UpdateSchema extends connector.Message {
    constructor(bucket: string, body: json);
  }

  /**
   * <p>Replace the class schema<br>Replace the schema definition of the class</p>
   */
  export class ReplaceSchema extends connector.Message {
    constructor(bucket: string, body: json);
  }

  /**
   * <p>Delete the class schema<br>Delete the schema definition of the class</p>
   */
  export class DeleteSchema extends connector.Message {
    constructor(bucket: string);
  }

  /**
   * <p>Executes a basic ad-hoc query<br>Executes the given query and returns a list of matching objects.</p>
   */
  export class AdhocQuery extends connector.Message {
    constructor(bucket: string, q: string, eager: boolean, hinted: boolean, start: number, count: number, sort: string);
  }

  /**
   * <p>Executes a basic ad-hoc query<br>Executes the given query and returns a list of matching objects.</p>
   */
  export class AdhocQueryPOST extends connector.Message {
    constructor(bucket: string, start: number, count: number, sort: string, body: string);
  }

  /**
   * <p>Executes a count query<br>Executes the given query and returns the number of objects that match the query</p>
   */
  export class AdhocCountQuery extends connector.Message {
    constructor(bucket: string, q: string);
  }

  /**
   * <p>Executes a count query<br>Executes the given query and returns the number of objects that match the query</p>
   */
  export class AdhocCountQueryPOST extends connector.Message {
    constructor(bucket: string, body: string);
  }

  /**
   * <p>List all Query subresources</p>
   */
  export class ListQueryResources extends connector.Message {
    constructor();
  }

  /**
   * <p>Creates a prepared query</p>
   */
  export class CreateQuery extends connector.Message {
    constructor(body: json);
  }

  /**
   * <p>List all subresources of a query</p>
   */
  export class ListThisQueryResources extends connector.Message {
    constructor(qid: string);
  }

  /**
   * <p>Get the query string</p>
   */
  export class GetQueryCode extends connector.Message {
    constructor(qid: string);
  }

  /**
   * <p>Executes a prepared query</p>
   */
  export class RunQuery extends connector.Message {
    constructor(start: number, count: number, qid: string);
  }

  /**
   * <p>Get the declared query parameters</p>
   */
  export class GetQueryParameters extends connector.Message {
    constructor(qid: string);
  }

  /**
   * <p>Starts a new Transaction</p>
   */
  export class NewTransaction extends connector.Message {
    constructor();
  }

  /**
   * <p>Commits the transaction<br>If the transaction can be completed a list of all changed objects with their updated versions are returned.</p>
   */
  export class CommitTransaction extends connector.Message {
    constructor(tid: string, body: json);
  }

  /**
   * <p>Update the object<br>Executes the partial updates on the object.<br>To update an object an explicit version must be provided in the If-Match header.<br>If the version is not equal to the current object version the update will be aborted.<br>The version identifier Any (*) can be used to skip the version validation and therefore<br>the update will always be applied.</p>
   */
  export class UpdatePartially extends connector.Message {
    constructor(bucket: string, oid: string, body: json);
  }

  /**
   * <p>Update the object field<br>Executes the partial update on a object field.<br>To update an object an explicit version must be provided in the If-Match header.<br>If the version is not equal to the current object version the update will be aborted.<br>The version identifier Any (*) can be used to skip the version validation and therefore<br>the update will always be applied.</p>
   */
  export class UpdateField extends connector.Message {
    constructor(bucket: string, field: string, oid: string, body: json);
  }

  /**
   * <p>Method to login a user<br>Log in a user by it's credentials</p>
   */
  export class Login extends connector.Message {
    constructor(body: json);
  }

  /**
   * <p>Method to register a user<br>Register and creates a new user</p>
   */
  export class Register extends connector.Message {
    constructor(body: json);
  }

  /**
   * <p>Method to load the current user object<br>Gets the user object of the currently logged in user</p>
   */
  export class Me extends connector.Message {
    constructor();
  }

  /**
   * <p>Method to validate a user token<br>Validates if a given token is still valid</p>
   */
  export class ValidateUser extends connector.Message {
    constructor();
  }

  /**
   * <p>Method to remove token cookie<br>Log out a user by removing the cookie token</p>
   */
  export class Logout extends connector.Message {
    constructor();
  }

  /**
   * <p>Method to change the password</p>
   */
  export class NewPassword extends connector.Message {
    constructor(body: json);
  }

  /**
   * <p>Method to request a new password</p>
   */
  export class ResetPassword extends connector.Message {
    constructor(body: json);
  }

  /**
   * <p>Method to verify user by a given token</p>
   */
  export class Verify extends connector.Message {
    constructor(token: string);
  }

  /**
   * <p>Method to request a change of the username</p>
   */
  export class ChangeUsername extends connector.Message {
    constructor(body: json);
  }

  /**
   * <p>Method to verify a username by a given token</p>
   */
  export class VerifyUsername extends connector.Message {
    constructor(token: string);
  }

  /**
   * <p>Method to register or login using an OAuth provider.<br>This resource is should be invoked by the provider with a redirect after the user granted permission.</p>
   */
  export class OAuth2 extends connector.Message {
    constructor(oauth_verifier: string, code: string, provider: string, oauth_token: string, error_description: string, state: string);
  }

  /**
   * <p>Method to invoke a OAuth-1.0 login/register<br>The resource requests a request-token and redirects the user to the provider page to log-in and grant permission for<br>your application.</p>
   */
  export class OAuth1 extends connector.Message {
    constructor(provider: string);
  }

  /**
   * <p>Generate a token without lifetime<br>Method to generate a token without lifetime</p>
   */
  export class UserToken extends connector.Message {
    constructor(oid: string);
  }

  /**
   * <p>Revoke all tokens<br>Method to revoke all previously created tokens</p>
   */
  export class RevokeUserToken extends connector.Message {
    constructor(oid: string);
  }

  /**
   * <p>Gets the code of the the given bucket and type</p>
   */
  export class GetBaqendCode extends connector.Message {
    constructor(bucket: string, type: string);
  }

  /**
   * <p>Sets the code of the bucket and type</p>
   */
  export class SetBaqendCode extends connector.Message {
    constructor(bucket: string, type: string, body: string);
  }

  /**
   * <p>Delete the code of the given bucket and type</p>
   */
  export class DeleteBaqendCode extends connector.Message {
    constructor(bucket: string, type: string);
  }

  /**
   * <p>Calls the module of the specific bucket</p>
   */
  export class PostBaqendModule extends connector.Message {
    constructor(bucket: string);
  }

  /**
   * <p>Calls the module of the specific bucket</p>
   */
  export class GetBaqendModule extends connector.Message {
    constructor(bucket: string);
  }

  /**
   * <p>List all available modules</p>
   */
  export class GetAllModules extends connector.Message {
    constructor();
  }

  /**
   * <p>Get all file ID's in the given folder<br>Retrieve meta-information about all accessible Files and folders in a specified folder.</p>
   */
  export class ListFiles extends connector.Message {
    constructor(bucket: string, path: string, deep: boolean, start: string, count: number);
  }

  /**
   * <p>Get all buckets<br>Gets all buckets.</p>
   */
  export class ListBuckets extends connector.Message {
    constructor();
  }

  /**
   * <p>Download a bucket archive<br>Downloads an archive containing the bucket contents.</p>
   */
  export class DownloadArchive extends connector.Message {
    constructor(archive: string);
  }

  /**
   * <p>Upload a patch bucket archive<br>Uploads an archive; files contained within that archive will be replaced within the bucket.</p>
   */
  export class UploadPatchArchive extends connector.Message {
    constructor(archive: string, body: string);
  }

  /**
   * <p>Retrieve the bucket Metadata<br>The bucket metadata object contains the bucketAcl.</p>
   */
  export class GetFileBucketMetadata extends connector.Message {
    constructor(bucket: string);
  }

  /**
   * <p>Set the Bucket Metadata<br>Creates or replaces the bucket Metadata to control permission access to all included Files.</p>
   */
  export class SetFileBucketMetadata extends connector.Message {
    constructor(bucket: string, body: json);
  }

  /**
   * <p>Delete all files of a file Bucket<br>Deletes the bucket and all its content.</p>
   */
  export class DeleteFileBucket extends connector.Message {
    constructor(bucket: string);
  }

  /**
   * <p>Creates a new file with a random UUID<br>Creates a file with a random ID, only Insert permissions are required.</p>
   */
  export class CreateFile extends connector.Message {
    constructor(bucket: string);
  }

  /**
   * <p>Download a file<br>Downloads a file by its ID.</p>
   */
  export class DownloadFile extends connector.Message {
    constructor(bucket: string, oid: string);
  }

  /**
   * <p>Upload a new file<br>Uploads and replace an existing file with a new one.<br>The If-Match or If-Unmodified-Since header can be used to make a conditional update</p>
   */
  export class UploadFile extends connector.Message {
    constructor(bucket: string, oid: string);
  }

  /**
   * <p>Get the file metadata<br>Gets the file Acl and metadata.</p>
   */
  export class GetFileMetadata extends connector.Message {
    constructor(bucket: string, oid: string);
  }

  /**
   * <p>Update File Metadata<br>Updates the file Metadata.</p>
   */
  export class UpdateFileMetadata extends connector.Message {
    constructor(bucket: string, oid: string, body: json);
  }

  /**
   * <p>Delete a file<br>Deletes a file or a folder with all its contents.<br>The If-Match or If-Unmodified-Since header can be used to make a conditional deletion</p>
   */
  export class DeleteFile extends connector.Message {
    constructor(bucket: string, oid: string);
  }

  /**
   * <p>Creates the manifest<br>Creates the manifest with the given data</p>
   */
  export class CreateManifest extends connector.Message {
    constructor(body: json);
  }

  /**
   * <p>Downloads (and clones) an external asset<br>Downloads an external file.</p>
   */
  export class DownloadAsset extends connector.Message {
    constructor(url: string);
  }

  /**
   * <p>Checks and purges assets<br>Checks and purges assets for the SpeedKit.</p>
   */
  export class RevalidateAssets extends connector.Message {
    constructor(body: json);
  }

  /**
   * <p>Gets the status<br>Get the current status of the revalidation</p>
   */
  export class GetRevalidationStatus extends connector.Message {
    constructor(id: string);
  }

  /**
   * <p>List bucket indexes<br>List all indexes of the given bucket</p>
   */
  export class ListIndexes extends connector.Message {
    constructor(bucket: string);
  }

  /**
   * <p>Create or drop bucket index<br>Create or drop a index for the given bucket</p>
   */
  export class CreateDropIndex extends connector.Message {
    constructor(bucket: string, body: json);
  }

  /**
   * <p>Drop all indexes<br>Drop all indexes on the given bucket</p>
   */
  export class DropAllIndexes extends connector.Message {
    constructor(bucket: string);
  }

  /**
   * <p>Method to register a new device<br>Registers a new devices</p>
   */
  export class DeviceRegister extends connector.Message {
    constructor(body: json);
  }

  /**
   * <p>Method to push a message to devices<br>Pushes a message to devices</p>
   */
  export class DevicePush extends connector.Message {
    constructor(body: json);
  }

  /**
   * <p>Check if device is registered<br>Checks if the device is already registered</p>
   */
  export class DeviceRegistered extends connector.Message {
    constructor();
  }

  /**
   * <p>Generate VAPID Keys<br>Generate VAPID Keys for web push</p>
   */
  export class VAPIDKeys extends connector.Message {
    constructor();
  }

  /**
   * <p>Get VAPID Public Key<br>Get VAPID Public Key for web push</p>
   */
  export class VAPIDPublicKey extends connector.Message {
    constructor();
  }

  /**
   * <p>Set GCM-API-Key<br>Sets the GCM/FCM API-Key for Android Push</p>
   */
  export class GCMAKey extends connector.Message {
    constructor(body: string);
  }

  /**
   * <p>Upload APNS certificate<br>Upload APNS certificate for IOS Push</p>
   */
  export class UploadAPNSCertificate extends connector.Message {
    constructor();
  }
}

export namespace metamodel {

  export class Attribute {
    constructor(name: string, isMetadata?: boolean);
    readonly persistentAttributeType: Attribute.PersistentAttributeType;
    readonly isAssociation: boolean;
    readonly isCollection: boolean;
    isMetadata: boolean;
    isId: boolean;
    isVersion: boolean;
    isAcl: boolean;
    name: string;
    order: number;
    accessor: binding.Accessor;
    declaringType: metamodel.ManagedType;
    metadata: { [key: string]: string } | null;
    init(declaringType: metamodel.ManagedType, order: number): void;
    getValue(entity: object): any;
    setValue(entity: object, value: any): void;
    /** <p>Retrieves whether this type has specific metadata</p> */
    hasMetadata(key: string): boolean;
    /** <p>Gets some metadata of this type</p> */
    getMetadata(key: string): null | string;
    /** <p>Gets this attribute value form the object as json</p> */
    getJsonValue(state: util.Metadata, object: any, options: object): any;
    /** <p>Sets this attribute value from json to the object</p> */
    setJsonValue(state: util.Metadata, object: any, jsonValue: any, options: object): void;
    /** <p>Converts this attribute field to json</p> */
    toJSON(): json;
  }

  /**
   * <p>Creates a new instance of a native db type</p>
   */
  export class BasicType extends metamodel.Type {
    constructor(ref: string, typeConstructor: Class<any>, noResolving?: boolean);
    noResolving: boolean;
  }

  export class CollectionAttribute extends metamodel.PluralAttribute {
    constructor(name: string, elementType: metamodel.Type);
  }

  /**
   * <p>Creates a new index instance which is needed to create an<br>database index.</p>
   */
  export class DbIndex {
    constructor(keys: string | { [key: string]: string } | { [key: string]: string }[], unique?: boolean);
    keys: { [key: string]: string }[];
    drop: boolean;
    /** <p>Indicates if this index is for the given field or includes it in a compound index</p> */
    hasKey(name: string): boolean;
    readonly isCompound: boolean;
    readonly isUnique: boolean;
    /** <p>Returns a JSON representation of the Index object</p> */
    toJSON(): json;
    static ASC: string;
    static DESC: string;
    static GEO: string;
    /** <p>Returns DbIndex Object created from the given JSON</p> */
    static fromJSON(json: json): metamodel.DbIndex;
  }

  export class EmbeddableType extends metamodel.ManagedType {
    constructor(ref: string, typeConstructor?: Class<binding.Entity>);
  }

  export class EntityType extends metamodel.ManagedType {
    constructor(ref: string, superType: metamodel.EntityType, typeConstructor?: Class<binding.Entity>);
    id: metamodel.SingularAttribute;
    version: metamodel.SingularAttribute;
    acl: metamodel.SingularAttribute;
    declaredId: metamodel.SingularAttribute;
    declaredVersion: metamodel.SingularAttribute;
    declaredAcl: metamodel.SingularAttribute;
    superType: metamodel.EntityType;
    loadPermission: util.Permission;
    updatePermission: util.Permission;
    deletePermission: util.Permission;
    queryPermission: util.Permission;
    schemaSubclassPermission: util.Permission;
    insertPermission: util.Permission;
    /** <p>Gets all on this class referencing attributes</p> */
    getReferencing(db: EntityManager, options?: { classes?: string[] }): Map<metamodel.ManagedType, Set<string>>;
    fromJsonValue(state: util.Metadata, jsonObject: json, currentObject: any, options?: { persisting?: boolean, onlyMetadata?: boolean }): any;
    /** <p>Converts the given object to json</p> */
    toJsonValue(state: util.Metadata, object: any, options?: { excludeMetadata?: boolean, depth?: number | boolean, persisting?: boolean }): json;
  }

  export class ListAttribute extends metamodel.PluralAttribute {
    constructor(name: string, elementType: metamodel.Type);
  }

  export class ManagedType extends metamodel.Type {
    constructor(ref: string, typeConstructor?: Class<binding.Managed>);
    validationCode: Function;
    typeConstructor: Class<binding.Managed>;
    enhancer: binding.Enhancer;
    declaredAttributes: metamodel.Attribute[];
    schemaAddPermission: util.Permission;
    schemaReplacePermission: util.Permission;
    metadata: { [key: string]: string } | null;
    /** <p>Initialize this type</p> */
    init(enhancer: binding.Enhancer): void;
    /** <p>Creates an ProxyClass for this type</p> */
    createProxyClass(): Class<any>;
    /** <p>Creates an ObjectFactory for this type and the given EntityManager</p> */
    createObjectFactory(db: EntityManager): binding.ManagedFactory<any>;
    /** <p>Creates a new instance of the managed type, without invoking any constructors</p> <p>This method is used to create object instances which are loaded form the backend.</p> */
    create(): object;
    /** <p>An iterator which returns all attributes declared by this type and inherited form all super types</p> */
    attributes(): Iterator<metamodel.Attribute>;
    /** <p>Adds an attribute to this type</p> */
    addAttribute(attr: metamodel.Attribute, order?: number): void;
    /** <p>Removes an attribute from this type</p> */
    removeAttribute(name: string): void;
    getAttribute(name: string): metamodel.Attribute;
    getDeclaredAttribute(val: string | number): metamodel.Attribute;
    /** <p>Converts ths type schema to json</p> */
    toJSON(): json;
    /** <p>Returns iterator to get all referenced entities</p> */
    references(): Iterator<'json' | 'text' | 'blob' | 'buffer' | 'arraybuffer' | 'data-url' | 'form'>;
    /** <p>Retrieves whether this type has specific metadata</p> */
    hasMetadata(key: string): boolean;
    /** <p>Gets some metadata of this type</p> */
    getMetadata(key: string): null | string;
  }

  export class MapAttribute extends metamodel.PluralAttribute {
    constructor(name: string, keyType: metamodel.Type, elementType: metamodel.Type, flags?: object);
    keyType: metamodel.Type;
  }

  /**
   * <p>Constructs a new metamodel instance which represents the complete schema of one baqend app</p>
   */
  export class Metamodel extends util.Lockable {
    constructor(entityManagerFactory?: EntityManagerFactory);
    isInitialized: boolean;
    entityManagerFactory: EntityManagerFactory;
    entities: { [key: string]: metamodel.EntityType };
    embeddables: { [key: string]: metamodel.EmbeddableType };
    baseTypes: { [key: string]: metamodel.BasicType };
    enhancer: binding.Enhancer;
    /** <p>Prepare the Metamodel for custom schema creation</p> */
    init(jsonMetamodel?: object): void;
    getRef(arg: Class<binding.Managed> | string): string;
    /** <p>Return the metamodel entity type representing the entity.</p> */
    entity(typeConstructor: Class<binding.Entity> | string): metamodel.EntityType;
    /** <p>Return the metamodel basic type representing the native class.</p> */
    baseType(typeConstructor: Class<any> | string): metamodel.BasicType;
    /** <p>Return the metamodel embeddable type representing the embeddable class.</p> */
    embeddable(typeConstructor: Class<binding.Managed> | string): metamodel.EmbeddableType;
    /** <p>Return the metamodel managed type representing the entity, mapped superclass, or embeddable class.</p> */
    managedType(typeConstructor: Class<binding.Managed> | string): metamodel.Type;
    addType(type: metamodel.Type): metamodel.Type;
    /** <p>Load all schema data from the server</p> */
    load(): Promise<metamodel.Metamodel>;
    /** <p>Store all local schema data on the server, or the provided one</p> <p>Note: The schema must be initialized, by init or load</p> */
    save(managedType?: metamodel.ManagedType): Promise<metamodel.Metamodel>;
    /** <p>Update the metamodel with the schema</p> <p>The provided data object will be forwarded to the UpdateAllSchemas resource.<br>The underlying schema of this Metamodel object will be replaced by the result.</p> */
    update(data: json): Promise<metamodel.Metamodel>;
    /** <p>Get the current schema types as json</p> */
    toJSON(): json;
    /** <p>Replace the current schema by the provided one in json</p> */
    fromJSON(json: json): void;
    /** <p>Creates an index</p> */
    createIndex(bucket: string, index: metamodel.DbIndex): Promise<any>;
    /** <p>Drops an index</p> */
    dropIndex(bucket: string, index: metamodel.DbIndex): Promise<any>;
    /** <p>Drops all indexes</p> */
    dropAllIndexes(bucket: string): Promise<any>;
    /** <p>Loads all indexes for the given bucket</p> */
    getIndexes(bucket: string): Promise<metamodel.DbIndex[]>;
  }

  export class ModelBuilder {
    constructor();
    models: { [key: string]: metamodel.ManagedType };
    modelDescriptors: { [key: string]: object };
    getModel(ref: string): metamodel.ManagedType;
    buildModels(modelDescriptors: object[]): { [key: string]: metamodel.ManagedType };
    buildModel(ref: string): metamodel.ManagedType;
    buildAttributes(model: metamodel.EntityType): void;
    buildAttribute(field: { name: string, type: string, order: number, metadata: { [key: string]: any } }): metamodel.Attribute;
  }

  export class PluralAttribute extends metamodel.Attribute {
    constructor(name: string, elementType: metamodel.Type);
    /** <p>Returns the previously attached state of the given collection</p> */
    static getAttachedState(collection: any[] | Set<any> | Map<any, any>): any[] | null;
    /** <p>Attach the the given state on the collection, in a meaner that it isn't enumerable</p> */
    static attachState(collection: any[] | Set<any> | Map<any, any>, state: any[]): void;
    /** <p>Returns the previously attached size of the given collection</p> */
    static getAttachedSize(collection: Set<any> | Map<any, any>): number;
    /** <p>Attach the the given size on the collection, in a meaner that it isn't enumerable</p> */
    static attachSize(collection: Set<any> | Map<any, any>, size: any[]): void;
    readonly collectionType: PluralAttribute.CollectionType;
    elementType: metamodel.Type;
    typeConstructor: Class<any>;
  }

  export class SetAttribute extends metamodel.PluralAttribute {
    constructor(name: string, elementType: metamodel.Type, flags?: object);
  }

  export class SingularAttribute extends metamodel.Attribute {
    constructor(name: string, type: metamodel.Type, isMetadata?: boolean);
    typeConstructor: Class<any>;
    type: metamodel.Type;
  }

  export class Type {
    constructor(ref: string, typeConstructor?: Class<any>);
    readonly persistenceType: number;
    readonly isBasic: boolean;
    readonly isEmbeddable: boolean;
    readonly isEntity: boolean;
    readonly isMappedSuperclass: boolean;
    ref: string;
    name: string;
    /** <p>Merge the json data into the current object instance and returns the merged object</p> */
    fromJsonValue(state: util.Metadata, jsonValue: json, currentValue: any, options: { onlyMetadata?: boolean }): any;
    /** <p>Converts the given object to json</p> */
    toJsonValue(state: util.Metadata, object: any, options: { excludeMetadata?: boolean, depth?: number | boolean }): json;
  }

  export namespace EntityType {

    export class Object extends metamodel.EntityType {
      constructor();
    }
  }

  export namespace Attribute {

    export enum PersistentAttributeType {
      BASIC = 0,
      ELEMENT_COLLECTION = 1,
      EMBEDDED = 2,
      MANY_TO_MANY = 3,
      MANY_TO_ONE = 4,
      ONE_TO_MANY = 5,
      ONE_TO_ONE = 6,
    }
  }

  export namespace PluralAttribute {

    export enum CollectionType {
      COLLECTION = 0,
      LIST = 1,
      MAP = 2,
      SET = 3,
    }
  }

  export namespace Type {

    export enum PersistenceType {
      BASIC = 0,
      EMBEDDABLE = 1,
      ENTITY = 2,
      MAPPED_SUPERCLASS = 3,
    }
  }
}

export namespace model {

  /**
   * <p>Users are representations of people using the app.</p>
   */
  export interface User extends binding.User {
  }

  /**
   * <p>Roles are aggregations of multiple Users with a given purpose.</p>
   */
  export interface Role extends binding.Role {
  }

  /**
   * <p>Devices are connected to the app to be contactable.</p>
   */
  export interface Device extends binding.Entity {
  }
}

export namespace partialupdate {

  export class EntityPartialUpdateBuilder<T> extends partialupdate.PartialUpdateBuilder<T> {
    constructor(entity: binding.Entity, operations: json);
    entity: binding.Entity;
  }

  export class PartialUpdateBuilder<T> {
    constructor(operations: json);
    operations: UpdateOperation[];
    /** <p>Sets a field to a given value</p> */
    set(field: string, value: any): this;
    /** <p>Increments a field by a given value</p> */
    inc(field: string, by?: number): this;
    /** <p>Decrements a field by a given value</p> */
    dec(field: string, by?: number): this;
    /** <p>Multiplies a field by a given number</p> */
    mul(field: string, multiplicator: number): this;
    /** <p>Divides a field by a given number</p> */
    div(field: string, divisor: number): this;
    /** <p>Sets the highest possible value of a field</p> */
    min(field: string, value: number): this;
    /** <p>Sets the smallest possible value of a field</p> */
    max(field: string, value: number): this;
    /** <p>Removes an item from an array or map</p> */
    remove(field: string, item: any): this;
    /** <p>Puts an item from an array or map</p> */
    put(field: string, key: string, value?: any): this;
    /** <p>Pushes an item into a list</p> */
    push(field: string, item: any): this;
    /** <p>Unshifts an item into a list</p> */
    unshift(field: string, item: any): this;
    /** <p>Pops the last item out of a list</p> */
    pop(field: string): this;
    /** <p>Shifts the first item out of a list</p> */
    shift(field: string): this;
    /** <p>Adds an item to a set</p> */
    add(field: string, item: any): this;
    /** <p>Replaces an item at a given index</p> */
    replace(path: string, index: number, item: any): this;
    /** <p>Sets a datetime field to the current moment</p> */
    currentDate(field: string): this;
    /** <p>Performs a bitwise AND on a path</p> */
    and(path: string, bitmask: number): this;
    /** <p>Performs a bitwise OR on a path</p> */
    or(path: string, bitmask: number): this;
    /** <p>Performs a bitwise XOR on a path</p> */
    xor(path: string, bitmask: number): this;
    /** <p>Renames a field</p> */
    rename(oldPath: string, newPath: string): this;
    /** <p>Returns a JSON representation of this partial update</p> */
    toJSON(): json;
    /** <p>Executes the partial update</p> */
    execute(): Promise<T>;
    /** <p>Increments a field by a given value</p> */
    increment(field: string, by?: number): this;
    /** <p>Decrements a field by a given value</p> */
    decrement(field: string, by?: number): this;
    /** <p>Multiplies a field by a given number</p> */
    multiply(field: string, multiplicator: number): this;
    /** <p>Divides a field by a given number</p> */
    divide(field: string, divisor: number): this;
    /** <p>Sets the highest possible value of a field</p> */
    atMost(field: string, value: number): this;
    /** <p>Sets the smallest possible value of a field</p> */
    atLeast(field: string, value: number): this;
    /** <p>Sets a datetime field to the current moment</p> */
    toNow(field: string): this;
  }

  export class UpdateOperation {
    constructor(operationName: string, path: string, value?: any);
  }
}

export namespace query {

  /**
   * <p>The Query Builder allows creating filtered and combined queries</p>
   */
  export class Builder<T> extends query.Query<T> implements query.Condition<T> {
    constructor();
    /** <p>Joins the conditions by an logical AND</p> */
    and(...args: (query.Query<T> | query.Query<T>[])[]): query.Operator<T>;
    /** <p>Joins the conditions by an logical OR</p> */
    or(...args: (query.Query<T> | query.Query<T>[])[]): query.Operator<T>;
    /** <p>Joins the conditions by an logical NOR</p> */
    nor(...args: (query.Query<T> | query.Query<T>[])[]): query.Operator<T>;
    /** <p>Adds a filter to this query</p> */
    addFilter(field: string, filter: string, value: any): query.Filter<T>;
    /** <p>An object that contains filter rules which will be merged with the current filters of this query</p> */
    where(conditions: json): query.Filter<T>;
    /** <p>Adds a equal filter to the field. All other other filters on the field will be discarded</p> */
    equal(field: string, value: any): query.Filter<T>;
    /** <p>Adds a not equal filter to the field</p> */
    notEqual(field: string, value: any): query.Filter<T>;
    /** <p>Adds a greater than filter to the field</p> */
    greaterThan(field: string, value: number | string | Date | binding.Entity): query.Filter<T>;
    /** <p>Adds a greater than or equal to filter to the field</p> */
    greaterThanOrEqualTo(field: string, value: number | string | Date | binding.Entity): query.Filter<T>;
    /** <p>Adds a less than filter to the field</p> */
    lessThan(field: string, value: number | string | Date | binding.Entity): query.Filter<T>;
    /** <p>Adds a less than or equal to filter to the field</p> */
    lessThanOrEqualTo(field: string, value: number | string | Date | binding.Entity): query.Filter<T>;
    /** <p>Adds a between filter to the field. This is a shorthand for an less than and greater than filter.</p> */
    between(field: string, greaterValue: number | string | Date | binding.Entity, lessValue: number | string | Date | binding.Entity): query.Filter<T>;
    /** <p>Adds a “in” filter to the field</p> <p>The field value must be equal to one of the given values.</p> */
    in(field: string, ...args: (any | any[])[]): query.Filter<T>;
    /** <p>Adds a “not in” filter to the field</p> <p>The field value must not be equal to any of the given values.</p> */
    notIn(field: string, ...args: (any | any[])[]): query.Filter<T>;
    /** <p>Adds a “is null” filter to the field</p> <p>The field value must be null.</p> */
    isNull(field: string): query.Filter<T>;
    /** <p>Adds a “is not null” filter to the field</p> <p>The field value must not be null.</p> */
    isNotNull(field: string): query.Filter<T>;
    /** <p>Adds a contains all filter to the collection field</p> <p>The collection must contain all the given values.</p> */
    containsAll(field: string, ...args: (any | any[])[]): query.Filter<T>;
    /** <p>Adds a modulo filter to the field</p> <p>The field value divided by divisor must be equal to the remainder.</p> */
    mod(field: string, divisor: number, remainder: number): query.Filter<T>;
    /** <p>Adds a regular expression filter to the field</p> <p>The field value must matches the regular expression.</p> <p>Note: Only anchored expressions (Expressions that starts with an ^) and the multiline flag are supported.</p> */
    matches(field: string, regExp: string | RegExp): query.Filter<T>;
    /** <p>Adds a size filter to the collection field</p> <p>The collection must have exactly size members.</p> */
    size(field: string, size: number): query.Filter<T>;
    /** <p>Adds a geopoint based near filter to the GeoPoint field</p> <p>The GeoPoint must be within the maximum distance<br>to the given GeoPoint. Returns from nearest to farthest.</p> */
    near(field: string, geoPoint: GeoPoint, maxDistance: number): query.Filter<T>;
    /** <p>Adds a GeoPoint based polygon filter to the GeoPoint field</p> <p>The GeoPoint must be contained within the given polygon.</p> */
    withinPolygon(field: string, ...geoPoints: (GeoPoint | GeoPoint[])[]): query.Filter<T>;
    /** <p>Adds a equal filter to the field</p> <p>All other other filters on the field will be discarded.</p> */
    eq(field: string, value: any): query.Filter<T>;
    /** <p>Adds a not equal filter to the field</p> */
    ne(field: string, value: any): query.Filter<T>;
    /** <p>Adds a less than filter to the field</p> <p>Shorthand for {@link query.Condition#lessThan}.</p> */
    lt(field: string, value: number | string | Date | binding.Entity): query.Filter<T>;
    /** <p>Adds a less than or equal to filter to the field</p> <p>Shorthand for {@link query.Condition#lessThanOrEqualTo}.</p> */
    le(field: string, value: number | string | Date | binding.Entity): query.Filter<T>;
    /** <p>Adds a greater than filter to the field</p> <p>Shorthand for {@link query.Condition#greaterThan}.</p> */
    gt(field: string, value: number | string | Date | binding.Entity): query.Filter<T>;
    /** <p>Adds a greater than or equal to filter to the field</p> <p>Shorthand for {@link query.Condition#greaterThanOrEqualTo}.</p> */
    ge(field: string, value: number | string | Date | binding.Entity): query.Filter<T>;
    /** <p>The collection must contains one of the given values</p> <p>Adds a contains any filter to the collection field.<br>Alias for {@link query.Condition#in}.</p> */
    containsAny(field: string, ...args: (any | any[])[]): query.Filter<T>;
    /** <p>Adds a filter to this query</p> */
    addFilter(field: string, filter: string, value: any): query.Filter<T>;
  }

  /**
   * <p>The Condition interface defines all existing query filters</p>
   */
  export interface Condition<T> {
    /** <p>An object that contains filter rules which will be merged with the current filters of this query</p> */
    where(conditions: json): query.Filter<T>;
    /** <p>Adds a equal filter to the field. All other other filters on the field will be discarded</p> */
    equal(field: string, value: any): query.Filter<T>;
    /** <p>Adds a not equal filter to the field</p> */
    notEqual(field: string, value: any): query.Filter<T>;
    /** <p>Adds a greater than filter to the field</p> */
    greaterThan(field: string, value: number | string | Date | binding.Entity): query.Filter<T>;
    /** <p>Adds a greater than or equal to filter to the field</p> */
    greaterThanOrEqualTo(field: string, value: number | string | Date | binding.Entity): query.Filter<T>;
    /** <p>Adds a less than filter to the field</p> */
    lessThan(field: string, value: number | string | Date | binding.Entity): query.Filter<T>;
    /** <p>Adds a less than or equal to filter to the field</p> */
    lessThanOrEqualTo(field: string, value: number | string | Date | binding.Entity): query.Filter<T>;
    /** <p>Adds a between filter to the field. This is a shorthand for an less than and greater than filter.</p> */
    between(field: string, greaterValue: number | string | Date | binding.Entity, lessValue: number | string | Date | binding.Entity): query.Filter<T>;
    /** <p>Adds a “in” filter to the field</p> <p>The field value must be equal to one of the given values.</p> */
    in(field: string, ...args: (any | any[])[]): query.Filter<T>;
    /** <p>Adds a “not in” filter to the field</p> <p>The field value must not be equal to any of the given values.</p> */
    notIn(field: string, ...args: (any | any[])[]): query.Filter<T>;
    /** <p>Adds a “is null” filter to the field</p> <p>The field value must be null.</p> */
    isNull(field: string): query.Filter<T>;
    /** <p>Adds a “is not null” filter to the field</p> <p>The field value must not be null.</p> */
    isNotNull(field: string): query.Filter<T>;
    /** <p>Adds a contains all filter to the collection field</p> <p>The collection must contain all the given values.</p> */
    containsAll(field: string, ...args: (any | any[])[]): query.Filter<T>;
    /** <p>Adds a modulo filter to the field</p> <p>The field value divided by divisor must be equal to the remainder.</p> */
    mod(field: string, divisor: number, remainder: number): query.Filter<T>;
    /** <p>Adds a regular expression filter to the field</p> <p>The field value must matches the regular expression.</p> <p>Note: Only anchored expressions (Expressions that starts with an ^) and the multiline flag are supported.</p> */
    matches(field: string, regExp: string | RegExp): query.Filter<T>;
    /** <p>Adds a size filter to the collection field</p> <p>The collection must have exactly size members.</p> */
    size(field: string, size: number): query.Filter<T>;
    /** <p>Adds a geopoint based near filter to the GeoPoint field</p> <p>The GeoPoint must be within the maximum distance<br>to the given GeoPoint. Returns from nearest to farthest.</p> */
    near(field: string, geoPoint: GeoPoint, maxDistance: number): query.Filter<T>;
    /** <p>Adds a GeoPoint based polygon filter to the GeoPoint field</p> <p>The GeoPoint must be contained within the given polygon.</p> */
    withinPolygon(field: string, ...geoPoints: (GeoPoint | GeoPoint[])[]): query.Filter<T>;
    /** <p>Adds a equal filter to the field</p> <p>All other other filters on the field will be discarded.</p> */
    eq(field: string, value: any): query.Filter<T>;
    /** <p>Adds a not equal filter to the field</p> */
    ne(field: string, value: any): query.Filter<T>;
    /** <p>Adds a less than filter to the field</p> <p>Shorthand for {@link query.Condition#lessThan}.</p> */
    lt(field: string, value: number | string | Date | binding.Entity): query.Filter<T>;
    /** <p>Adds a less than or equal to filter to the field</p> <p>Shorthand for {@link query.Condition#lessThanOrEqualTo}.</p> */
    le(field: string, value: number | string | Date | binding.Entity): query.Filter<T>;
    /** <p>Adds a greater than filter to the field</p> <p>Shorthand for {@link query.Condition#greaterThan}.</p> */
    gt(field: string, value: number | string | Date | binding.Entity): query.Filter<T>;
    /** <p>Adds a greater than or equal to filter to the field</p> <p>Shorthand for {@link query.Condition#greaterThanOrEqualTo}.</p> */
    ge(field: string, value: number | string | Date | binding.Entity): query.Filter<T>;
    /** <p>The collection must contains one of the given values</p> <p>Adds a contains any filter to the collection field.<br>Alias for {@link query.Condition#in}.</p> */
    containsAny(field: string, ...args: (any | any[])[]): query.Filter<T>;
    /** <p>Adds a filter to this query</p> */
    addFilter(field: string, filter: string, value: any): query.Filter<T>;
  }

  /**
   * <p>A Filter saves the state for a filtered query</p>
   */
  export class Filter<T> extends query.Node<T> implements query.Condition<T> {
    constructor(entityManager: EntityManager, resultClass: Class<T>);
    readonly filter: { [key: string]: any };
    /** <p>Adds a filter to this query</p> */
    addFilter(field: string, filter: string, value: any): query.Filter<T>;
    /** <p>An object that contains filter rules which will be merged with the current filters of this query</p> */
    where(conditions: json): query.Filter<T>;
    /** <p>Adds a equal filter to the field. All other other filters on the field will be discarded</p> */
    equal(field: string, value: any): query.Filter<T>;
    /** <p>Adds a not equal filter to the field</p> */
    notEqual(field: string, value: any): query.Filter<T>;
    /** <p>Adds a greater than filter to the field</p> */
    greaterThan(field: string, value: number | string | Date | binding.Entity): query.Filter<T>;
    /** <p>Adds a greater than or equal to filter to the field</p> */
    greaterThanOrEqualTo(field: string, value: number | string | Date | binding.Entity): query.Filter<T>;
    /** <p>Adds a less than filter to the field</p> */
    lessThan(field: string, value: number | string | Date | binding.Entity): query.Filter<T>;
    /** <p>Adds a less than or equal to filter to the field</p> */
    lessThanOrEqualTo(field: string, value: number | string | Date | binding.Entity): query.Filter<T>;
    /** <p>Adds a between filter to the field. This is a shorthand for an less than and greater than filter.</p> */
    between(field: string, greaterValue: number | string | Date | binding.Entity, lessValue: number | string | Date | binding.Entity): query.Filter<T>;
    /** <p>Adds a “in” filter to the field</p> <p>The field value must be equal to one of the given values.</p> */
    in(field: string, ...args: (any | any[])[]): query.Filter<T>;
    /** <p>Adds a “not in” filter to the field</p> <p>The field value must not be equal to any of the given values.</p> */
    notIn(field: string, ...args: (any | any[])[]): query.Filter<T>;
    /** <p>Adds a “is null” filter to the field</p> <p>The field value must be null.</p> */
    isNull(field: string): query.Filter<T>;
    /** <p>Adds a “is not null” filter to the field</p> <p>The field value must not be null.</p> */
    isNotNull(field: string): query.Filter<T>;
    /** <p>Adds a contains all filter to the collection field</p> <p>The collection must contain all the given values.</p> */
    containsAll(field: string, ...args: (any | any[])[]): query.Filter<T>;
    /** <p>Adds a modulo filter to the field</p> <p>The field value divided by divisor must be equal to the remainder.</p> */
    mod(field: string, divisor: number, remainder: number): query.Filter<T>;
    /** <p>Adds a regular expression filter to the field</p> <p>The field value must matches the regular expression.</p> <p>Note: Only anchored expressions (Expressions that starts with an ^) and the multiline flag are supported.</p> */
    matches(field: string, regExp: string | RegExp): query.Filter<T>;
    /** <p>Adds a size filter to the collection field</p> <p>The collection must have exactly size members.</p> */
    size(field: string, size: number): query.Filter<T>;
    /** <p>Adds a geopoint based near filter to the GeoPoint field</p> <p>The GeoPoint must be within the maximum distance<br>to the given GeoPoint. Returns from nearest to farthest.</p> */
    near(field: string, geoPoint: GeoPoint, maxDistance: number): query.Filter<T>;
    /** <p>Adds a GeoPoint based polygon filter to the GeoPoint field</p> <p>The GeoPoint must be contained within the given polygon.</p> */
    withinPolygon(field: string, ...geoPoints: (GeoPoint | GeoPoint[])[]): query.Filter<T>;
    /** <p>Adds a equal filter to the field</p> <p>All other other filters on the field will be discarded.</p> */
    eq(field: string, value: any): query.Filter<T>;
    /** <p>Adds a not equal filter to the field</p> */
    ne(field: string, value: any): query.Filter<T>;
    /** <p>Adds a less than filter to the field</p> <p>Shorthand for {@link query.Condition#lessThan}.</p> */
    lt(field: string, value: number | string | Date | binding.Entity): query.Filter<T>;
    /** <p>Adds a less than or equal to filter to the field</p> <p>Shorthand for {@link query.Condition#lessThanOrEqualTo}.</p> */
    le(field: string, value: number | string | Date | binding.Entity): query.Filter<T>;
    /** <p>Adds a greater than filter to the field</p> <p>Shorthand for {@link query.Condition#greaterThan}.</p> */
    gt(field: string, value: number | string | Date | binding.Entity): query.Filter<T>;
    /** <p>Adds a greater than or equal to filter to the field</p> <p>Shorthand for {@link query.Condition#greaterThanOrEqualTo}.</p> */
    ge(field: string, value: number | string | Date | binding.Entity): query.Filter<T>;
    /** <p>The collection must contains one of the given values</p> <p>Adds a contains any filter to the collection field.<br>Alias for {@link query.Condition#in}.</p> */
    containsAny(field: string, ...args: (any | any[])[]): query.Filter<T>;
    /** <p>Adds a filter to this query</p> */
    addFilter(field: string, filter: string, value: any): query.Filter<T>;
  }

  /**
   * <p>A Query Node saves the state of the query being built</p>
   */
  export class Node<T> extends query.Query<T> {
    constructor(entityManager: EntityManager, resultClass: Class<T>);
    readonly firstResult: number;
    readonly maxResults: number;
    readonly order: { [key: string]: number };
  }

  /**
   * <p>An Operator saves the state of a combined query</p>
   */
  export class Operator<T> extends query.Node<T> {
    constructor(entityManager: EntityManager, resultClass: Class<T>, operator: string, childs: query.Node<T>[]);
    readonly operator: string;
    readonly childs: query.Node<T>[];
  }

  /**
   * <p>An abstract Query which allows retrieving results</p>
   */
  export class Query<T> {
    constructor();
    readonly entityManager: EntityManager;
    readonly resultClass: Class<T>;
    /** <p>Add an ascending sort for the specified field to this query</p> */
    ascending(field: string): this;
    /** <p>Add an decending sort for the specified field to this query</p> */
    descending(field: string): this;
    /** <p>Sets the sort of the query and discard all existing paramaters</p> */
    sort(sort: { [key: string]: number }): this;
    /** <p>Sets the offset of the query, i.e. how many elements should be skipped</p> */
    offset(offset: number): this;
    /** <p>Sets the limit of this query, i.e hox many objects should be returnd</p> */
    limit(limit: number): this;
    /** <p>Execute the query and return the query results as a List</p> <p>Note: All local unsaved changes on matching objects, will be discarded.</p> */
    resultList(options?: { depth?: number | boolean }, doneCallback?: (result: T[]) => Promise<any> | any, failCallback?: (error: error.PersistentError) => Promise<any> | any): Promise<T[]>;
    /** <p>Execute the query and return the query results as a List</p> <p>Note: All local unsaved changes on matching objects, will be discarded.</p> */
    resultList(doneCallback?: (result: T[]) => Promise<any> | any, failCallback?: (error: error.PersistentError) => Promise<any> | any): Promise<T[]>;
    /** <p>Execute the query that returns a single result</p> <p>Note: All local unsaved changes on the matched object, will be discarded.</p> */
    singleResult(options?: { depth?: number | boolean }, doneCallback?: (entity: T) => Promise<any> | any, failCallback?: (error: error.PersistentError) => Promise<any> | any): Promise<T | null>;
    /** <p>Execute the query that returns a single result</p> <p>Note: All local unsaved changes on the matched object, will be discarded.</p> */
    singleResult(doneCallback?: (entity: T) => Promise<any> | any, failCallback?: (error: error.PersistentError) => Promise<any> | any): Promise<T | null>;
    /** <p>Returns an observable that receives change events for a real-time query</p> <p>Multiple subscriptions can be created on top of this observable:</p> <pre><code> var query = DB.Todo.find(); var options = { ... }; var stream = query.eventStream(options); var sub = stream.subscribe(onNext, onError, onComplete); var otherSub = stream.subscribe(otherOnNext, otherOnError, otherOnComplete); </code></pre> */
    eventStream(options?: { initial?: boolean, matchTypes?: string | string[], operations?: string | string[] }): Observable<RealtimeEvent<T>>;
    /** <p>Returns a subscription that handles change events for a real-time query.</p> <p>The underlying stream object is hidden. To create multiple subscriptions on the same stream, create the stream<br>object first and then subscribe to the stream (see the other signature {@link #eventStream(options)}).</p> */
    eventStream(options?: { initial?: boolean, matchTypes?: string | string[], operations?: string | string[] }, onNext?: (event: RealtimeEvent<T>) => any, onError?: (error: error.PersistentError) => Promise<any> | any, onComplete?: Function): Subscription;
    /** <p>Returns a subscription that handles change events for a real-time query.</p> <p>The underlying stream object is hidden. To create multiple subscriptions on the same stream, create the stream<br>object first and then subscribe to the stream (see the other signature {@link #eventStream(options)}).</p> */
    eventStream(onNext?: (event: RealtimeEvent<T>) => any, onError?: (error: error.PersistentError) => Promise<any> | any, onComplete?: Function): Subscription;
    /** <p>Returns an observable that receives the complete real-time query result</p> <p>The full result is received initially (i.e. on subscription) and on every change.</p> <p>var query = DB.Todo.find();<br>var stream = query.resultStream();<br>var sub = stream.subscribe(onNext, onError, onComplete);<br>var otherSub = stream.subscribe(otherOnNext, otherOnError, otherOnComplete);<br></code></pre></p> */
    resultStream(options?: { reconnects?: number }): Observable<T[]>;
    /** <p>Returns a subscription that handles the complete real-time query result</p> <p>The full result is received initially (i.e. on subscription) and on every change.</p> <p>The underlying stream object is hidden. To create multiple subscriptions on the same stream, create the stream<br>object first and then subscribe to the stream (see the other signature {@link #resultStream(options)}).</p> */
    resultStream(options?: { reconnects?: number }, onNext?: (result: T[]) => any, onError?: (error: error.PersistentError) => Promise<any> | any, onComplete?: Function): Subscription;
    /** <p>Returns a subscription that handles the complete real-time query result</p> <p>The full result is received initially (i.e. on subscription) and on every change.</p> <p>The underlying stream object is hidden. To create multiple subscriptions on the same stream, create the stream<br>object first and then subscribe to the stream (see the other signature {@link #resultStream(options)}).</p> <p>As the real-time query will reconnect infinitely often, there is no onComplete callback. (In other words, the<br>observable will never complete.)</p> */
    resultStream(onNext?: (result: T[]) => any, onError?: (error: error.PersistentError) => Promise<any> | any): Subscription;
    /** <p>Execute the query that returns the matching objects count.</p> */
    count(doneCallback?: (count: number) => Promise<any> | any, failCallback?: (error: error.PersistentError) => Promise<any> | any): Promise<number>;
  }

  export class Stream {
    constructor();
    /** <p>Creates a live updating object stream for a query</p> */
    static createStream<T>(entityManager: EntityManager, query: string | { query: string, bucket: string, sort?: string, limit?: number, offset?: number, initial?: boolean }, options: Partial<{ initial: boolean, matchTypes: string[], operations: string[], reconnects: number }>): Observable<RealtimeEvent<T>>;
    /** <p>Creates a live updating result stream for a query</p> */
    static createStreamResult<T>(entityManager: EntityManager, query: string | { query: string, bucket: string, sort?: string, limit?: number, offset?: number }, options: Partial<{ initial: boolean, matchTypes: string[], operations: string[], reconnects: number }>): Observable<T[]>;
    /** <p>Parses the StreamOptions</p> */
    static parseOptions(options?: Partial<{ initial: boolean, matchTypes: string[], operations: string[], reconnects: number }>): { initial: boolean, matchTypes: string[], operations: string[], reconnects: number };
  }
}

export namespace util {

  /**
   * <p>Converts Base64-encoded data to string.</p>
   */
  export function atob(input: string): string;

  /**
   * <p>Calculates a Keyed-Hash Message Authentication Code (HMAC) from a message and a key.</p>
   */
  export function hmac(message: string, key: string): string;

  /**
   * <p>Generates a new Universally Unique Identifier (UUID) version 4.</p>
   */
  export function uuid(): string;

  /**
   * <p>Representation of a Code which runs on Baqend.</p>
   */
  export class Code {
    constructor(metamodel: metamodel.Metamodel, entityManagerFactory: EntityManagerFactory);
    metamodel: metamodel.Metamodel;
    entityManagerFactory: EntityManagerFactory;
    /** <p>Converts the given function to a string</p> */
    functionToString(fn: Function): string;
    /** <p>Converts the given string to a module wrapper function</p> */
    stringToFunction(signature: string[], code: string): Function;
    /** <p>Loads a list of all available modules without handlers</p> */
    loadModules(): Promise<string[]>;
    /** <p>Loads Baqend code which will be identified by the given bucket and code type</p> */
    loadCode(type: metamodel.ManagedType | string, codeType: string, asFunction: true): Promise<Function>;
    /** <p>Loads Baqend code which will be identified by the given bucket and code type</p> */
    loadCode(type: metamodel.ManagedType | string, codeType: string, asFunction?: false): Promise<string>;
    /** <p>Saves Baqend code which will be identified by the given bucket and code type</p> */
    saveCode(type: metamodel.ManagedType | string, codeType: string, fn: string): Promise<string>;
    /** <p>Saves Baqend code which will be identified by the given bucket and code type</p> */
    saveCode(type: metamodel.ManagedType | string, codeType: string, fn: Function): Promise<Function>;
    /** <p>Deletes Baqend code identified by the given bucket and code type</p> */
    deleteCode(type: metamodel.ManagedType | string, codeType: string): Promise<any>;
  }

  /**
   * <p>This base class provides an lock interface to execute exclusive operations</p>
   */
  export class Lockable {
    constructor();
    isReady: boolean;
    /** <p>Waits on the previously requested operation and calls the doneCallback if the operation is fulfilled</p> */
    ready(doneCallback?: (entity: this) => Promise<any> | any, failCallback?: (error: Error) => Promise<any> | any): Promise<this>;
    /** <p>Try to aquire an exclusive lock and executes the given callback.</p> */
    withLock<T>(callback: Function, critical?: boolean): Promise<T>;
  }

  /**
   * <p>A Logger to store log notes when running the app.</p>
   */
  export class Logger {
    constructor();
    /** <p>Creates a Logger instance for the given EntityManager</p> */
    static create(entityManager: EntityManager): util.Logger;
    level: string;
    /** <p>Logs a message in the default level 'info'</p> */
    log(message: string, ...args: any[]): void;
    /** <p>Logs a message in the default level 'info'</p> */
    log(message: string, data?: { [key: string]: any }): void;
    /** <p>Logs a message with the given log level</p> */
    log(level: string, message: string, ...args: any[]): void;
    /** <p>Logs a message with the given log level</p> */
    log(level: string, message: string, data?: { [key: string]: any }): Promise<any> | null;
    entityManager: EntityManager;
    /** <p>Log message at trace level</p> */
    trace(message: string, ...args: any[]): Promise<any> | null;
    /** <p>Log message at trace level</p> */
    trace(message: string, data?: { [key: string]: any }): Promise<any> | null;
    /** <p>Log message at debug level</p> */
    debug(message: string, ...args: any[]): Promise<any> | null;
    /** <p>Log message at debug level</p> */
    debug(message: string, data?: { [key: string]: any }): Promise<any> | null;
    /** <p>Log message at info level</p> */
    info(message: string, ...args: any[]): Promise<any> | null;
    /** <p>Log message at info level</p> */
    info(message: string, data?: { [key: string]: any }): Promise<any> | null;
    /** <p>Log message at warn level</p> */
    warn(message: string, ...args: any[]): Promise<any> | null;
    /** <p>Log message at warn level</p> */
    warn(message: string, data?: { [key: string]: any }): Promise<any> | null;
    /** <p>Log message at error level</p> */
    error(message: string, ...args: any[]): Promise<any> | null;
    /** <p>Log message at error level</p> */
    error(message: string, data?: { [key: string]: any }): Promise<any> | null;
  }

  /**
   * <p>The Metadata instance tracks the state of an object and checks if the object state was changed since last<br>load/update. The metadata keeps therefore the state of:</p>
   * <ul>
   * <li>in which state the object currently is</li>
   * <li>which db managed the instance</li>
   * <li>the metadata of the object (id, version, bucket)</li>
   * <li>which is the owning object (root object) of an embedded object</li>
   * </ul>
   * <p>{@link util.Metadata#get(object)} can be used on any managed object to retrieve the metadata of the root object</p>
   */
  export class Metadata extends util.Lockable {
    constructor(entity: binding.Entity, type: metamodel.ManagedType);
    /** <p>Creates a metadata instance for the given type and object instance</p> */
    static create(type: metamodel.ManagedType, object: any): any;
    /** <p>Returns the metadata of the managed object</p> */
    static get(managed: binding.Managed): util.Metadata;
    db: EntityManager;
    readonly bucket: string;
    readonly key: string;
    readonly isAttached: boolean;
    readonly isAvailable: boolean;
    readonly isPersistent: boolean;
    readonly isDirty: boolean;
    id: string;
    version: number;
    type: metamodel.ManagedType;
    acl: Acl;
    /** <p>Enable/Disable state change tracking of this object</p> */
    enable(newStateTrackingState: boolean): void;
    /** <p>Signals that the object will be accessed by a read</p> <p>Ensures that the object was loaded already.</p> */
    readAccess(): void;
    /** <p>Signals that the object will be accessed by a write</p> <p>Ensures that the object was loaded already and marks the object as dirty.</p> */
    writeAccess(): void;
    /** <p>Indicates that the associated object isn't available</p> */
    setUnavailable(): void;
    /** <p>Indicates that the associated object is not stale</p> <p>An object is stale if it correlates the database state and is not modified by the user.</p> */
    setPersistent(): void;
    /** <p>Indicates the the object is modified by the user</p> */
    setDirty(): void;
    /** <p>Indicates the the object is removed</p> */
    setRemoved(): void;
    /** @deprecated */
    getJson(options?: boolean | { excludeMetadata?: boolean, depth?: number, persisting?: boolean }): json;
    /** @deprecated */
    setJson(json: json, options?: { persisting?: boolean, onlyMetadata: boolean }): void;
  }

  /**
   * <p>An executor of Modules running on Baqend.</p>
   */
  export class Modules {
    constructor(entityManager: EntityManager);
    entityManager: EntityManager;
    /** <p>Calls the module, which is identified by the given bucket</p> <p>The optional query parameter will be attached as GET-parameters.</p> */
    get(bucket: string, query?: { [key: string]: string } | string, options?: { responseType?: string }, doneCallback?: Function, failCallback?: Function): Promise<any>;
    /** <p>Calls the module, which is identified by the given bucket</p> */
    post(bucket: string, body?: string | Blob | File | ArrayBuffer | FormData | json, options?: { requestType?: string, mimeType?: string, responseType?: string }, doneCallback?: Function, failCallback?: Function): Promise<any>;
  }

  /**
   * <p>An aggregation of access rules for given object metadata.</p>
   */
  export class Permission {
    constructor(metadata?: util.Metadata);
    rules: { [key: string]: string };
    _metadata: util.Metadata;
    /** <p>Returns a list of user and role references of all rules</p> */
    allRules(): string[];
    /** <p>Removes all rules from this permission object</p> */
    clear(): void;
    /** <p>Copies permissions from another permission object</p> */
    copy(permission: util.Permission): util.Permission;
    /** <p>Gets whenever all users and roles have the permission to perform the operation</p> */
    isPublicAllowed(): boolean;
    /** <p>Sets whenever all users and roles should have the permission to perform the operation</p> <p>Note: All other allow rules will be removed.</p> */
    setPublicAllowed(): void;
    /** <p>Returns the actual rule of the given user or role.</p> */
    getRule(userOrRole: model.User | model.Role | string): string;
    /** <p>Checks whenever the user or role is explicit allowed to perform the operation.</p> */
    isAllowed(userOrRole: model.User | model.Role | string): boolean;
    /** <p>Checks whenever the user or role is explicit denied to perform the operation.</p> */
    isDenied(userOrRole: model.User | model.Role | string): boolean;
    /** <p>Allows the given users or rules to perform the operation</p> */
    allowAccess(...userOrRole: (model.User | model.Role | string)[]): util.Permission;
    /** <p>Denies the given users or rules to perform the operation</p> */
    denyAccess(...userOrRole: (model.User | model.Role | string)[]): util.Permission;
    /** <p>Deletes any allow/deny rules for the given users or roles</p> */
    deleteAccess(...userOrRole: (model.User | model.Role | string)[]): util.Permission;
    /** <p>A Json representation of the set of rules</p> */
    toJSON(): json;
    /** <p>Sets the permission rules from json</p> */
    fromJSON(json: json): void;
    /** <p>Creates a permission from the given rules.</p> */
    static fromJSON(json: json): util.Permission;
  }

  /**
   * <p>PushMessages are used to send a push notification to a set of devices</p>
   */
  export class PushMessage {
    constructor(devices?: Iterable<binding.Entity>, message?: string, subject?: string, options?: string | { icon?: string, badge?: string | number, nativeBadge?: number, webBadge?: string, image?: string, actions?: object, dir?: string, sound?: string, tag?: string, vibrate?: number[], renotify?: boolean, requireInteraction?: boolean, silent?: boolean, data?: any }, badge?: string | number, data?: any);
    readonly devices: Set<model.Device>;
    readonly message: string;
    readonly subject: string;
    /** <p>Adds a new object to the set of devices</p> */
    addDevice(device: binding.Entity): void;
    /** <p>Converts the push message to JSON</p> */
    toJSON(): json;
  }

  export interface TokenStorageFactory {
    /** <p>Creates a new tokenStorage which persist tokens for the given origin</p> */
    create(origin: string): Promise<TokenStorage>;
  }

  export class TokenStorage {
    constructor(origin: string, token: string, temporary?: boolean);
    /** <p>Parse a token string in its components</p> */
    static parse(token: string): object;
    temporary: boolean;
    /** <p>Use the underlying storage implementation to save the token</p> */
    saveToken(origin: string, token: string, temporary: boolean): void;
    /** @deprecated Use TokenStorage#saveToken instead */
    _saveToken(origin: string, token: string, temporary: boolean): void;
    /** <p>Update the token for the givin origin, the operation may be asynchronous</p> */
    update(token: String): void;
    /** <p>Derives a resource token from the stored origin token and signs the resource with the generated resource token</p> */
    signPath(resource: string): string;
    static GLOBAL: util.TokenStorageFactory;
    static WEB_STORAGE: util.TokenStorageFactory;
  }

  export class ValidationResult {
    constructor();
  }

  export class Validator {
    constructor();
    /** <p>Compiles the given validation code for the managedType</p> */
    static compile(managedType: metamodel.ManagedType, validationCode: string): void;
    /** <p>Executes the given validation function to validate the value.</p> <p>The value will be passed as the first parameter to the validation function and<br>the library {@link https://github.com/chriso/validator.js} as the second one.<br>If the function returns true the value is valid, otherwise it's invalid.</p> */
    is(fn: Function): util.Validator;
    /** <p>Executes the given validation function to validate the value.</p> <p>The value will be passed as the first parameter to the validation function and<br>the library {@link https://github.com/chriso/validator.js} as the second one.<br>If the function returns true the value is valid, otherwise it's invalid.</p> */
    is(error: string, fn: Function): util.Validator;
    key: string;
  }

  export namespace Metadata {

    export enum Type {
      UNAVAILABLE = -1,
      PERSISTENT = 0,
      DIRTY = 1,
    }
  }
}